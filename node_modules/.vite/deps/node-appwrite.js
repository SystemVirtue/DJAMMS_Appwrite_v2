import {
  __privateAdd,
  __privateMethod
} from "./chunk-Q4XP6UTR.js";

// node_modules/node-fetch-native-with-agent/dist/native.mjs
var e = globalThis.Blob;
var o = globalThis.File;
var a = globalThis.FormData;
var s = globalThis.Headers;
var t = globalThis.Request;
var h = globalThis.Response;
var i = globalThis.AbortController;
var l = globalThis.fetch || (() => {
  throw new Error("[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!");
});

// node_modules/node-fetch-native-with-agent/dist/agent-stub.mjs
var o2 = Object.defineProperty;
var e2 = (t2, c) => o2(t2, "name", { value: c, configurable: true });
var i2 = Object.defineProperty;
var r = e2((t2, c) => i2(t2, "name", { value: c, configurable: true }), "e");
function a2() {
  return { agent: void 0, dispatcher: void 0 };
}
e2(a2, "createAgent"), r(a2, "createAgent");
function n() {
  return globalThis.fetch;
}
e2(n, "createFetch"), r(n, "createFetch");
var h2 = globalThis.fetch;

// node_modules/node-appwrite/dist/query.mjs
var _Query = class _Query2 {
  /**
   * Constructor for Query class.
   *
   * @param {string} method
   * @param {AttributesTypes} attribute
   * @param {QueryTypes} values
   */
  constructor(method, attribute, values) {
    this.method = method;
    this.attribute = attribute;
    if (values !== void 0) {
      if (Array.isArray(values)) {
        this.values = values;
      } else {
        this.values = [values];
      }
    }
  }
  /**
   * Convert the query object to a JSON string.
   *
   * @returns {string}
   */
  toString() {
    return JSON.stringify({
      method: this.method,
      attribute: this.attribute,
      values: this.values
    });
  }
};
_Query.equal = (attribute, value) => new _Query("equal", attribute, value).toString();
_Query.notEqual = (attribute, value) => new _Query("notEqual", attribute, value).toString();
_Query.lessThan = (attribute, value) => new _Query("lessThan", attribute, value).toString();
_Query.lessThanEqual = (attribute, value) => new _Query("lessThanEqual", attribute, value).toString();
_Query.greaterThan = (attribute, value) => new _Query("greaterThan", attribute, value).toString();
_Query.greaterThanEqual = (attribute, value) => new _Query("greaterThanEqual", attribute, value).toString();
_Query.isNull = (attribute) => new _Query("isNull", attribute).toString();
_Query.isNotNull = (attribute) => new _Query("isNotNull", attribute).toString();
_Query.between = (attribute, start, end) => new _Query("between", attribute, [start, end]).toString();
_Query.startsWith = (attribute, value) => new _Query("startsWith", attribute, value).toString();
_Query.endsWith = (attribute, value) => new _Query("endsWith", attribute, value).toString();
_Query.select = (attributes) => new _Query("select", void 0, attributes).toString();
_Query.search = (attribute, value) => new _Query("search", attribute, value).toString();
_Query.orderDesc = (attribute) => new _Query("orderDesc", attribute).toString();
_Query.orderAsc = (attribute) => new _Query("orderAsc", attribute).toString();
_Query.orderRandom = () => new _Query("orderRandom").toString();
_Query.cursorAfter = (documentId) => new _Query("cursorAfter", void 0, documentId).toString();
_Query.cursorBefore = (documentId) => new _Query("cursorBefore", void 0, documentId).toString();
_Query.limit = (limit) => new _Query("limit", void 0, limit).toString();
_Query.offset = (offset) => new _Query("offset", void 0, offset).toString();
_Query.contains = (attribute, value) => new _Query("contains", attribute, value).toString();
_Query.notContains = (attribute, value) => new _Query("notContains", attribute, value).toString();
_Query.notSearch = (attribute, value) => new _Query("notSearch", attribute, value).toString();
_Query.notBetween = (attribute, start, end) => new _Query("notBetween", attribute, [start, end]).toString();
_Query.notStartsWith = (attribute, value) => new _Query("notStartsWith", attribute, value).toString();
_Query.notEndsWith = (attribute, value) => new _Query("notEndsWith", attribute, value).toString();
_Query.createdBefore = (value) => new _Query("createdBefore", void 0, value).toString();
_Query.createdAfter = (value) => new _Query("createdAfter", void 0, value).toString();
_Query.createdBetween = (start, end) => new _Query("createdBetween", void 0, [start, end]).toString();
_Query.updatedBefore = (value) => new _Query("updatedBefore", void 0, value).toString();
_Query.updatedAfter = (value) => new _Query("updatedAfter", void 0, value).toString();
_Query.updatedBetween = (start, end) => new _Query("updatedBetween", void 0, [start, end]).toString();
_Query.or = (queries) => new _Query("or", void 0, queries.map((query) => JSON.parse(query))).toString();
_Query.and = (queries) => new _Query("and", void 0, queries.map((query) => JSON.parse(query))).toString();
_Query.distanceEqual = (attribute, values, distance, meters = true) => new _Query("distanceEqual", attribute, [[values, distance, meters]]).toString();
_Query.distanceNotEqual = (attribute, values, distance, meters = true) => new _Query("distanceNotEqual", attribute, [[values, distance, meters]]).toString();
_Query.distanceGreaterThan = (attribute, values, distance, meters = true) => new _Query("distanceGreaterThan", attribute, [[values, distance, meters]]).toString();
_Query.distanceLessThan = (attribute, values, distance, meters = true) => new _Query("distanceLessThan", attribute, [[values, distance, meters]]).toString();
_Query.intersects = (attribute, values) => new _Query("intersects", attribute, [values]).toString();
_Query.notIntersects = (attribute, values) => new _Query("notIntersects", attribute, [values]).toString();
_Query.crosses = (attribute, values) => new _Query("crosses", attribute, [values]).toString();
_Query.notCrosses = (attribute, values) => new _Query("notCrosses", attribute, [values]).toString();
_Query.overlaps = (attribute, values) => new _Query("overlaps", attribute, [values]).toString();
_Query.notOverlaps = (attribute, values) => new _Query("notOverlaps", attribute, [values]).toString();
_Query.touches = (attribute, values) => new _Query("touches", attribute, [values]).toString();
_Query.notTouches = (attribute, values) => new _Query("notTouches", attribute, [values]).toString();
var Query = _Query;

// node_modules/node-appwrite/dist/client.mjs
var AppwriteException = class extends Error {
  constructor(message, code = 0, type = "", response = "") {
    super(message);
    this.name = "AppwriteException";
    this.message = message;
    this.code = code;
    this.type = type;
    this.response = response;
  }
};
function getUserAgent() {
  let ua = "AppwriteNodeJSSDK/19.1.0";
  const platform = [];
  if (typeof process !== "undefined") {
    if (typeof process.platform === "string")
      platform.push(process.platform);
    if (typeof process.arch === "string")
      platform.push(process.arch);
  }
  if (platform.length > 0) {
    ua += ` (${platform.join("; ")})`;
  }
  if (typeof navigator !== "undefined" && typeof navigator.userAgent === "string") {
    ua += ` ${navigator.userAgent}`;
  } else if (typeof globalThis.EdgeRuntime === "string") {
    ua += ` EdgeRuntime`;
  } else if (typeof process !== "undefined" && typeof process.version === "string") {
    ua += ` Node.js/${process.version}`;
  }
  return ua;
}
var _Client = class _Client2 {
  constructor() {
    this.config = {
      endpoint: "https://cloud.appwrite.io/v1",
      selfSigned: false,
      project: "",
      key: "",
      jwt: "",
      locale: "",
      session: "",
      forwardeduseragent: ""
    };
    this.headers = {
      "x-sdk-name": "Node.js",
      "x-sdk-platform": "server",
      "x-sdk-language": "nodejs",
      "x-sdk-version": "19.1.0",
      "user-agent": getUserAgent(),
      "X-Appwrite-Response-Format": "1.8.0"
    };
  }
  /**
   * Set Endpoint
   *
   * Your project endpoint
   *
   * @param {string} endpoint
   *
   * @returns {this}
   */
  setEndpoint(endpoint) {
    if (!endpoint.startsWith("http://") && !endpoint.startsWith("https://")) {
      throw new AppwriteException("Invalid endpoint URL: " + endpoint);
    }
    this.config.endpoint = endpoint;
    return this;
  }
  /**
   * Set self-signed
   *
   * @param {boolean} selfSigned
   *
   * @returns {this}
   */
  setSelfSigned(selfSigned) {
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      console.warn("setSelfSigned is not supported in edge runtimes.");
    }
    this.config.selfSigned = selfSigned;
    return this;
  }
  /**
   * Add header
   *
   * @param {string} header
   * @param {string} value
   *
   * @returns {this}
   */
  addHeader(header, value) {
    this.headers[header.toLowerCase()] = value;
    return this;
  }
  /**
   * Set Project
   *
   * Your project ID
   *
   * @param value string
   *
   * @return {this}
   */
  setProject(value) {
    this.headers["X-Appwrite-Project"] = value;
    this.config.project = value;
    return this;
  }
  /**
   * Set Key
   *
   * Your secret API key
   *
   * @param value string
   *
   * @return {this}
   */
  setKey(value) {
    this.headers["X-Appwrite-Key"] = value;
    this.config.key = value;
    return this;
  }
  /**
   * Set JWT
   *
   * Your secret JSON Web Token
   *
   * @param value string
   *
   * @return {this}
   */
  setJWT(value) {
    this.headers["X-Appwrite-JWT"] = value;
    this.config.jwt = value;
    return this;
  }
  /**
   * Set Locale
   *
   * @param value string
   *
   * @return {this}
   */
  setLocale(value) {
    this.headers["X-Appwrite-Locale"] = value;
    this.config.locale = value;
    return this;
  }
  /**
   * Set Session
   *
   * The user session to authenticate with
   *
   * @param value string
   *
   * @return {this}
   */
  setSession(value) {
    this.headers["X-Appwrite-Session"] = value;
    this.config.session = value;
    return this;
  }
  /**
   * Set ForwardedUserAgent
   *
   * The user agent string of the client that made the request
   *
   * @param value string
   *
   * @return {this}
   */
  setForwardedUserAgent(value) {
    this.headers["X-Forwarded-User-Agent"] = value;
    this.config.forwardeduseragent = value;
    return this;
  }
  prepareRequest(method, url, headers = {}, params = {}) {
    method = method.toUpperCase();
    headers = Object.assign({}, this.headers, headers);
    let options = {
      method,
      headers,
      ...a2(this.config.endpoint, { rejectUnauthorized: !this.config.selfSigned })
    };
    if (method === "GET") {
      for (const [key, value] of Object.entries(_Client2.flatten(params))) {
        url.searchParams.append(key, value);
      }
    } else {
      switch (headers["content-type"]) {
        case "application/json":
          options.body = JSON.stringify(params);
          break;
        case "multipart/form-data":
          const formData = new a();
          for (const [key, value] of Object.entries(params)) {
            if (value instanceof o) {
              formData.append(key, value, value.name);
            } else if (Array.isArray(value)) {
              for (const nestedValue of value) {
                formData.append(`${key}[]`, nestedValue);
              }
            } else {
              formData.append(key, value);
            }
          }
          options.body = formData;
          delete headers["content-type"];
          break;
      }
    }
    return { uri: url.toString(), options };
  }
  async chunkedUpload(method, url, headers = {}, originalPayload = {}, onProgress) {
    const [fileParam, file] = Object.entries(originalPayload).find(([_, value]) => value instanceof o) ?? [];
    if (!file || !fileParam) {
      throw new Error("File not found in payload");
    }
    if (file.size <= _Client2.CHUNK_SIZE) {
      return await this.call(method, url, headers, originalPayload);
    }
    let start = 0;
    let response = null;
    while (start < file.size) {
      let end = start + _Client2.CHUNK_SIZE;
      if (end >= file.size) {
        end = file.size;
      }
      headers["content-range"] = `bytes ${start}-${end - 1}/${file.size}`;
      const chunk = file.slice(start, end);
      let payload = { ...originalPayload };
      payload[fileParam] = new o([chunk], file.name);
      response = await this.call(method, url, headers, payload);
      if (onProgress && typeof onProgress === "function") {
        onProgress({
          $id: response.$id,
          progress: Math.round(end / file.size * 100),
          sizeUploaded: end,
          chunksTotal: Math.ceil(file.size / _Client2.CHUNK_SIZE),
          chunksUploaded: Math.ceil(end / _Client2.CHUNK_SIZE)
        });
      }
      if (response && response.$id) {
        headers["x-appwrite-id"] = response.$id;
      }
      start = end;
    }
    return response;
  }
  async ping() {
    return this.call("GET", new URL(this.config.endpoint + "/ping"));
  }
  async redirect(method, url, headers = {}, params = {}) {
    const { uri, options } = this.prepareRequest(method, url, headers, params);
    const response = await l(uri, {
      ...options,
      redirect: "manual"
    });
    if (response.status !== 301 && response.status !== 302) {
      throw new AppwriteException("Invalid redirect", response.status);
    }
    return response.headers.get("location") || "";
  }
  async call(method, url, headers = {}, params = {}, responseType = "json") {
    var _a2, _b;
    const { uri, options } = this.prepareRequest(method, url, headers, params);
    let data = null;
    const response = await l(uri, options);
    const warnings = response.headers.get("x-appwrite-warning");
    if (warnings) {
      warnings.split(";").forEach((warning) => console.warn("Warning: " + warning));
    }
    if ((_a2 = response.headers.get("content-type")) == null ? void 0 : _a2.includes("application/json")) {
      data = await response.json();
    } else if (responseType === "arrayBuffer") {
      data = await response.arrayBuffer();
    } else {
      data = {
        message: await response.text()
      };
    }
    if (400 <= response.status) {
      let responseText = "";
      if (((_b = response.headers.get("content-type")) == null ? void 0 : _b.includes("application/json")) || responseType === "arrayBuffer") {
        responseText = JSON.stringify(data);
      } else {
        responseText = data == null ? void 0 : data.message;
      }
      throw new AppwriteException(data == null ? void 0 : data.message, response.status, data == null ? void 0 : data.type, responseText);
    }
    return data;
  }
  static flatten(data, prefix = "") {
    let output = {};
    for (const [key, value] of Object.entries(data)) {
      let finalKey = prefix ? prefix + "[" + key + "]" : key;
      if (Array.isArray(value)) {
        output = { ...output, ..._Client2.flatten(value, finalKey) };
      } else {
        output[finalKey] = value;
      }
    }
    return output;
  }
};
_Client.CHUNK_SIZE = 1024 * 1024 * 5;
var Client = _Client;

// node_modules/node-appwrite/dist/services/account.mjs
var Account = class {
  constructor(client) {
    this.client = client;
  }
  /**
   * Get the currently logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.User<Preferences>>}
   */
  get() {
    const apiPath = "/account";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        name: rest[2]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEmail(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        email: paramsOrFirst,
        password: rest[0]
      };
    }
    const email = params.email;
    const password = params.password;
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/email";
    const payload = {};
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listIdentities(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst
      };
    }
    const queries = params.queries;
    const apiPath = "/account/identities";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteIdentity(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        identityId: paramsOrFirst
      };
    }
    const identityId = params.identityId;
    if (typeof identityId === "undefined") {
      throw new AppwriteException('Missing required parameter: "identityId"');
    }
    const apiPath = "/account/identities/{identityId}".replace("{identityId}", identityId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Use this endpoint to create a JSON Web Token. You can use the resulting JWT to authenticate on behalf of the current user when working with the Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes from its creation and will be invalid if the user will logout in that time frame.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.Jwt>}
   */
  createJWT() {
    const apiPath = "/account/jwts";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  listLogs(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst
      };
    }
    const queries = params.queries;
    const apiPath = "/account/logs";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMFA(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        mfa: paramsOrFirst
      };
    }
    const mfa = params.mfa;
    if (typeof mfa === "undefined") {
      throw new AppwriteException('Missing required parameter: "mfa"');
    }
    const apiPath = "/account/mfa";
    const payload = {};
    if (typeof mfa !== "undefined") {
      payload["mfa"] = mfa;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createMfaAuthenticator(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst
      };
    }
    const type = params.type;
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createMFAAuthenticator(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst
      };
    }
    const type = params.type;
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMfaAuthenticator(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst,
        otp: rest[0]
      };
    }
    const type = params.type;
    const otp = params.otp;
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    if (typeof otp === "undefined") {
      throw new AppwriteException('Missing required parameter: "otp"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    if (typeof otp !== "undefined") {
      payload["otp"] = otp;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMFAAuthenticator(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst,
        otp: rest[0]
      };
    }
    const type = params.type;
    const otp = params.otp;
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    if (typeof otp === "undefined") {
      throw new AppwriteException('Missing required parameter: "otp"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    if (typeof otp !== "undefined") {
      payload["otp"] = otp;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteMfaAuthenticator(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst
      };
    }
    const type = params.type;
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteMFAAuthenticator(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst
      };
    }
    const type = params.type;
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  createMfaChallenge(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "factor" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        factor: paramsOrFirst
      };
    }
    const factor = params.factor;
    if (typeof factor === "undefined") {
      throw new AppwriteException('Missing required parameter: "factor"');
    }
    const apiPath = "/account/mfa/challenge";
    const payload = {};
    if (typeof factor !== "undefined") {
      payload["factor"] = factor;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createMFAChallenge(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "factor" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        factor: paramsOrFirst
      };
    }
    const factor = params.factor;
    if (typeof factor === "undefined") {
      throw new AppwriteException('Missing required parameter: "factor"');
    }
    const apiPath = "/account/mfa/challenge";
    const payload = {};
    if (typeof factor !== "undefined") {
      payload["factor"] = factor;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMfaChallenge(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        challengeId: paramsOrFirst,
        otp: rest[0]
      };
    }
    const challengeId = params.challengeId;
    const otp = params.otp;
    if (typeof challengeId === "undefined") {
      throw new AppwriteException('Missing required parameter: "challengeId"');
    }
    if (typeof otp === "undefined") {
      throw new AppwriteException('Missing required parameter: "otp"');
    }
    const apiPath = "/account/mfa/challenge";
    const payload = {};
    if (typeof challengeId !== "undefined") {
      payload["challengeId"] = challengeId;
    }
    if (typeof otp !== "undefined") {
      payload["otp"] = otp;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMFAChallenge(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        challengeId: paramsOrFirst,
        otp: rest[0]
      };
    }
    const challengeId = params.challengeId;
    const otp = params.otp;
    if (typeof challengeId === "undefined") {
      throw new AppwriteException('Missing required parameter: "challengeId"');
    }
    if (typeof otp === "undefined") {
      throw new AppwriteException('Missing required parameter: "otp"');
    }
    const apiPath = "/account/mfa/challenge";
    const payload = {};
    if (typeof challengeId !== "undefined") {
      payload["challengeId"] = challengeId;
    }
    if (typeof otp !== "undefined") {
      payload["otp"] = otp;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List the factors available on the account to be used as a MFA challange.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaFactors>}
   * @deprecated This API has been deprecated since 1.8.0. Please use `Account.listMFAFactors` instead.
   */
  listMfaFactors() {
    const apiPath = "/account/mfa/factors";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List the factors available on the account to be used as a MFA challange.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaFactors>}
   */
  listMFAFactors() {
    const apiPath = "/account/mfa/factors";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   * @deprecated This API has been deprecated since 1.8.0. Please use `Account.getMFARecoveryCodes` instead.
   */
  getMfaRecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   */
  getMFARecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   * @deprecated This API has been deprecated since 1.8.0. Please use `Account.createMFARecoveryCodes` instead.
   */
  createMfaRecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   */
  createMFARecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   * @deprecated This API has been deprecated since 1.8.0. Please use `Account.updateMFARecoveryCodes` instead.
   */
  updateMfaRecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   */
  updateMFARecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updateName(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        name: paramsOrFirst
      };
    }
    const name = params.name;
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/account/name";
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePassword(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        password: paramsOrFirst,
        oldPassword: rest[0]
      };
    }
    const password = params.password;
    const oldPassword = params.oldPassword;
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/password";
    const payload = {};
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof oldPassword !== "undefined") {
      payload["oldPassword"] = oldPassword;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePhone(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        phone: paramsOrFirst,
        password: rest[0]
      };
    }
    const phone = params.phone;
    const password = params.password;
    if (typeof phone === "undefined") {
      throw new AppwriteException('Missing required parameter: "phone"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/phone";
    const payload = {};
    if (typeof phone !== "undefined") {
      payload["phone"] = phone;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get the preferences as a key-value object for the currently logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Preferences>}
   */
  getPrefs() {
    const apiPath = "/account/prefs";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePrefs(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "prefs" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        prefs: paramsOrFirst
      };
    }
    const prefs = params.prefs;
    if (typeof prefs === "undefined") {
      throw new AppwriteException('Missing required parameter: "prefs"');
    }
    const apiPath = "/account/prefs";
    const payload = {};
    if (typeof prefs !== "undefined") {
      payload["prefs"] = prefs;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createRecovery(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        email: paramsOrFirst,
        url: rest[0]
      };
    }
    const email = params.email;
    const url = params.url;
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof url === "undefined") {
      throw new AppwriteException('Missing required parameter: "url"');
    }
    const apiPath = "/account/recovery";
    const payload = {};
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateRecovery(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0],
        password: rest[1]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    const password = params.password;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new AppwriteException('Missing required parameter: "secret"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/recovery";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get the list of active sessions across different devices for the currently logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.SessionList>}
   */
  listSessions() {
    const apiPath = "/account/sessions";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Delete all sessions from the user account and remove any sessions cookies from the end client.
   *
   * @throws {AppwriteException}
   * @returns {Promise<{}>}
   */
  deleteSessions() {
    const apiPath = "/account/sessions";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Use this endpoint to allow a new user to register an anonymous account in your project. This route will also create a new session for the user. To allow the new user to convert an anonymous account to a normal account, you need to update its [email and password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail) or create an [OAuth2 session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.Session>}
   */
  createAnonymousSession() {
    const apiPath = "/account/sessions/anonymous";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createEmailPasswordSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        email: paramsOrFirst,
        password: rest[0]
      };
    }
    const email = params.email;
    const password = params.password;
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/sessions/email";
    const payload = {};
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMagicURLSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/sessions/magic-url";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePhoneSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/sessions/phone";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  createSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/sessions/token";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getSession(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        sessionId: paramsOrFirst
      };
    }
    const sessionId = params.sessionId;
    if (typeof sessionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "sessionId"');
    }
    const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateSession(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        sessionId: paramsOrFirst
      };
    }
    const sessionId = params.sessionId;
    if (typeof sessionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "sessionId"');
    }
    const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteSession(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        sessionId: paramsOrFirst
      };
    }
    const sessionId = params.sessionId;
    if (typeof sessionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "sessionId"');
    }
    const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Block the currently logged in user account. Behind the scene, the user record is not deleted but permanently blocked from any access. To completely delete a user, use the Users API instead.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.User<Preferences>>}
   */
  updateStatus() {
    const apiPath = "/account/status";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createEmailToken(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        phrase: rest[1]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const phrase = params.phrase;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    const apiPath = "/account/tokens/email";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof phrase !== "undefined") {
      payload["phrase"] = phrase;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createMagicURLToken(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        url: rest[1],
        phrase: rest[2]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const url = params.url;
    const phrase = params.phrase;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    const apiPath = "/account/tokens/magic-url";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    if (typeof phrase !== "undefined") {
      payload["phrase"] = phrase;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createOAuth2Token(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "provider" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        provider: paramsOrFirst,
        success: rest[0],
        failure: rest[1],
        scopes: rest[2]
      };
    }
    const provider = params.provider;
    const success = params.success;
    const failure = params.failure;
    const scopes = params.scopes;
    if (typeof provider === "undefined") {
      throw new AppwriteException('Missing required parameter: "provider"');
    }
    const apiPath = "/account/tokens/oauth2/{provider}".replace("{provider}", provider);
    const payload = {};
    if (typeof success !== "undefined") {
      payload["success"] = success;
    }
    if (typeof failure !== "undefined") {
      payload["failure"] = failure;
    }
    if (typeof scopes !== "undefined") {
      payload["scopes"] = scopes;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.redirect(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createPhoneToken(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        phone: rest[0]
      };
    }
    const userId = params.userId;
    const phone = params.phone;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof phone === "undefined") {
      throw new AppwriteException('Missing required parameter: "phone"');
    }
    const apiPath = "/account/tokens/phone";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof phone !== "undefined") {
      payload["phone"] = phone;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createVerification(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        url: paramsOrFirst
      };
    }
    const url = params.url;
    if (typeof url === "undefined") {
      throw new AppwriteException('Missing required parameter: "url"');
    }
    const apiPath = "/account/verification";
    const payload = {};
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateVerification(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/verification";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Use this endpoint to send a verification SMS to the currently logged in user. This endpoint is meant for use after updating a user's phone number using the [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone) endpoint. Learn more about how to [complete the verification process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification). The verification code sent to the user's phone number is valid for 15 minutes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.Token>}
   */
  createPhoneVerification() {
    const apiPath = "/account/verification/phone";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePhoneVerification(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/verification/phone";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/avatars.mjs
var Avatars = class {
  constructor(client) {
    this.client = client;
  }
  getBrowser(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "code" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        code: paramsOrFirst,
        width: rest[0],
        height: rest[1],
        quality: rest[2]
      };
    }
    const code = params.code;
    const width = params.width;
    const height = params.height;
    const quality = params.quality;
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    const apiPath = "/avatars/browsers/{code}".replace("{code}", code);
    const payload = {};
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof quality !== "undefined") {
      payload["quality"] = quality;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  getCreditCard(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "code" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        code: paramsOrFirst,
        width: rest[0],
        height: rest[1],
        quality: rest[2]
      };
    }
    const code = params.code;
    const width = params.width;
    const height = params.height;
    const quality = params.quality;
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    const apiPath = "/avatars/credit-cards/{code}".replace("{code}", code);
    const payload = {};
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof quality !== "undefined") {
      payload["quality"] = quality;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  getFavicon(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        url: paramsOrFirst
      };
    }
    const url = params.url;
    if (typeof url === "undefined") {
      throw new AppwriteException('Missing required parameter: "url"');
    }
    const apiPath = "/avatars/favicon";
    const payload = {};
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  getFlag(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "code" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        code: paramsOrFirst,
        width: rest[0],
        height: rest[1],
        quality: rest[2]
      };
    }
    const code = params.code;
    const width = params.width;
    const height = params.height;
    const quality = params.quality;
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    const apiPath = "/avatars/flags/{code}".replace("{code}", code);
    const payload = {};
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof quality !== "undefined") {
      payload["quality"] = quality;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  getImage(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        url: paramsOrFirst,
        width: rest[0],
        height: rest[1]
      };
    }
    const url = params.url;
    const width = params.width;
    const height = params.height;
    if (typeof url === "undefined") {
      throw new AppwriteException('Missing required parameter: "url"');
    }
    const apiPath = "/avatars/image";
    const payload = {};
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  getInitials(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        name: paramsOrFirst,
        width: rest[0],
        height: rest[1],
        background: rest[2]
      };
    }
    const name = params.name;
    const width = params.width;
    const height = params.height;
    const background = params.background;
    const apiPath = "/avatars/initials";
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof background !== "undefined") {
      payload["background"] = background;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  getQR(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        text: paramsOrFirst,
        size: rest[0],
        margin: rest[1],
        download: rest[2]
      };
    }
    const text = params.text;
    const size = params.size;
    const margin = params.margin;
    const download = params.download;
    if (typeof text === "undefined") {
      throw new AppwriteException('Missing required parameter: "text"');
    }
    const apiPath = "/avatars/qr";
    const payload = {};
    if (typeof text !== "undefined") {
      payload["text"] = text;
    }
    if (typeof size !== "undefined") {
      payload["size"] = size;
    }
    if (typeof margin !== "undefined") {
      payload["margin"] = margin;
    }
    if (typeof download !== "undefined") {
      payload["download"] = download;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
};

// node_modules/node-appwrite/dist/services/databases.mjs
var Databases = class {
  constructor(client) {
    this.client = client;
  }
  list(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/databases";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const name = params.name;
    const enabled = params.enabled;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/databases";
    const payload = {};
    if (typeof databaseId !== "undefined") {
      payload["databaseId"] = databaseId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  get(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst
      };
    }
    const databaseId = params.databaseId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  update(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const name = params.name;
    const enabled = params.enabled;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst
      };
    }
    const databaseId = params.databaseId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listCollections(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        queries: rest[0],
        search: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const queries = params.queries;
    const search = params.search;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    const apiPath = "/databases/{databaseId}/collections".replace("{databaseId}", databaseId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createCollection(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        name: rest[1],
        permissions: rest[2],
        documentSecurity: rest[3],
        enabled: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const name = params.name;
    const permissions = params.permissions;
    const documentSecurity = params.documentSecurity;
    const enabled = params.enabled;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/databases/{databaseId}/collections".replace("{databaseId}", databaseId);
    const payload = {};
    if (typeof collectionId !== "undefined") {
      payload["collectionId"] = collectionId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    if (typeof documentSecurity !== "undefined") {
      payload["documentSecurity"] = documentSecurity;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getCollection(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateCollection(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        name: rest[1],
        permissions: rest[2],
        documentSecurity: rest[3],
        enabled: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const name = params.name;
    const permissions = params.permissions;
    const documentSecurity = params.documentSecurity;
    const enabled = params.enabled;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    if (typeof documentSecurity !== "undefined") {
      payload["documentSecurity"] = documentSecurity;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteCollection(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listAttributes(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        queries: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createBooleanAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/boolean".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateBooleanAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/boolean/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createDatetimeAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/datetime".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateDatetimeAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/datetime/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createEmailAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/email".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEmailAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/email/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createEnumAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        elements: rest[2],
        required: rest[3],
        xdefault: rest[4],
        array: rest[5]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const elements = params.elements;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof elements === "undefined") {
      throw new AppwriteException('Missing required parameter: "elements"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/enum".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof elements !== "undefined") {
      payload["elements"] = elements;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEnumAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        elements: rest[2],
        required: rest[3],
        xdefault: rest[4],
        newKey: rest[5]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const elements = params.elements;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof elements === "undefined") {
      throw new AppwriteException('Missing required parameter: "elements"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/enum/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof elements !== "undefined") {
      payload["elements"] = elements;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createFloatAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        min: rest[3],
        max: rest[4],
        xdefault: rest[5],
        array: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const min = params.min;
    const max = params.max;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/float".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateFloatAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        min: rest[4],
        max: rest[5],
        newKey: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const min = params.min;
    const max = params.max;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/float/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createIntegerAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        min: rest[3],
        max: rest[4],
        xdefault: rest[5],
        array: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const min = params.min;
    const max = params.max;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/integer".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateIntegerAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        min: rest[4],
        max: rest[5],
        newKey: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const min = params.min;
    const max = params.max;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/integer/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createIpAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/ip".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateIpAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/ip/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createLineAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/line".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateLineAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/line/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createPointAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/point".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePointAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/point/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createPolygonAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/polygon".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePolygonAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/polygon/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createRelationshipAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        relatedCollectionId: rest[1],
        type: rest[2],
        twoWay: rest[3],
        key: rest[4],
        twoWayKey: rest[5],
        onDelete: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const relatedCollectionId = params.relatedCollectionId;
    const type = params.type;
    const twoWay = params.twoWay;
    const key = params.key;
    const twoWayKey = params.twoWayKey;
    const onDelete = params.onDelete;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof relatedCollectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "relatedCollectionId"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/relationship".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof relatedCollectionId !== "undefined") {
      payload["relatedCollectionId"] = relatedCollectionId;
    }
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    if (typeof twoWay !== "undefined") {
      payload["twoWay"] = twoWay;
    }
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof twoWayKey !== "undefined") {
      payload["twoWayKey"] = twoWayKey;
    }
    if (typeof onDelete !== "undefined") {
      payload["onDelete"] = onDelete;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createStringAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        size: rest[2],
        required: rest[3],
        xdefault: rest[4],
        array: rest[5],
        encrypt: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const size = params.size;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    const encrypt = params.encrypt;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof size === "undefined") {
      throw new AppwriteException('Missing required parameter: "size"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/string".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof size !== "undefined") {
      payload["size"] = size;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    if (typeof encrypt !== "undefined") {
      payload["encrypt"] = encrypt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateStringAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        size: rest[4],
        newKey: rest[5]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const size = params.size;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/string/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof size !== "undefined") {
      payload["size"] = size;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createUrlAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/url".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateUrlAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/url/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  getAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  updateRelationshipAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        onDelete: rest[2],
        newKey: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const onDelete = params.onDelete;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}/relationship".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    if (typeof onDelete !== "undefined") {
      payload["onDelete"] = onDelete;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listDocuments(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        queries: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createDocument(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documentId: rest[1],
        data: rest[2],
        permissions: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documentId = params.documentId;
    const data = params.data;
    const permissions = params.permissions;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "documentId"');
    }
    if (typeof data === "undefined") {
      throw new AppwriteException('Missing required parameter: "data"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof documentId !== "undefined") {
      payload["documentId"] = documentId;
    }
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createDocuments(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documents: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documents = params.documents;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documents === "undefined") {
      throw new AppwriteException('Missing required parameter: "documents"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof documents !== "undefined") {
      payload["documents"] = documents;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  upsertDocuments(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documents: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documents = params.documents;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documents === "undefined") {
      throw new AppwriteException('Missing required parameter: "documents"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof documents !== "undefined") {
      payload["documents"] = documents;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateDocuments(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        data: rest[1],
        queries: rest[2]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const data = params.data;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteDocuments(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        queries: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  getDocument(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documentId: rest[1],
        queries: rest[2]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documentId = params.documentId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "documentId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  upsertDocument(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documentId: rest[1],
        data: rest[2],
        permissions: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documentId = params.documentId;
    const data = params.data;
    const permissions = params.permissions;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "documentId"');
    }
    if (typeof data === "undefined") {
      throw new AppwriteException('Missing required parameter: "data"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
    const payload = {};
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateDocument(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documentId: rest[1],
        data: rest[2],
        permissions: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documentId = params.documentId;
    const data = params.data;
    const permissions = params.permissions;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "documentId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
    const payload = {};
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteDocument(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documentId: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documentId = params.documentId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "documentId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  decrementDocumentAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documentId: rest[1],
        attribute: rest[2],
        value: rest[3],
        min: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documentId = params.documentId;
    const attribute = params.attribute;
    const value = params.value;
    const min = params.min;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "documentId"');
    }
    if (typeof attribute === "undefined") {
      throw new AppwriteException('Missing required parameter: "attribute"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/decrement".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId).replace("{attribute}", attribute);
    const payload = {};
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  incrementDocumentAttribute(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        documentId: rest[1],
        attribute: rest[2],
        value: rest[3],
        max: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const documentId = params.documentId;
    const attribute = params.attribute;
    const value = params.value;
    const max = params.max;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof documentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "documentId"');
    }
    if (typeof attribute === "undefined") {
      throw new AppwriteException('Missing required parameter: "attribute"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/increment".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId).replace("{attribute}", attribute);
    const payload = {};
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listIndexes(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        queries: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createIndex(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1],
        type: rest[2],
        attributes: rest[3],
        orders: rest[4],
        lengths: rest[5]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    const type = params.type;
    const attributes = params.attributes;
    const orders = params.orders;
    const lengths = params.lengths;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    if (typeof attributes === "undefined") {
      throw new AppwriteException('Missing required parameter: "attributes"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    if (typeof attributes !== "undefined") {
      payload["attributes"] = attributes;
    }
    if (typeof orders !== "undefined") {
      payload["orders"] = orders;
    }
    if (typeof lengths !== "undefined") {
      payload["lengths"] = lengths;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getIndex(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteIndex(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        collectionId: rest[0],
        key: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const collectionId = params.collectionId;
    const key = params.key;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof collectionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "collectionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/functions.mjs
var Functions = class {
  constructor(client) {
    this.client = client;
  }
  list(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/functions";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        name: rest[0],
        runtime: rest[1],
        execute: rest[2],
        events: rest[3],
        schedule: rest[4],
        timeout: rest[5],
        enabled: rest[6],
        logging: rest[7],
        entrypoint: rest[8],
        commands: rest[9],
        scopes: rest[10],
        installationId: rest[11],
        providerRepositoryId: rest[12],
        providerBranch: rest[13],
        providerSilentMode: rest[14],
        providerRootDirectory: rest[15],
        specification: rest[16]
      };
    }
    const functionId = params.functionId;
    const name = params.name;
    const runtime = params.runtime;
    const execute = params.execute;
    const events = params.events;
    const schedule = params.schedule;
    const timeout = params.timeout;
    const enabled = params.enabled;
    const logging = params.logging;
    const entrypoint = params.entrypoint;
    const commands = params.commands;
    const scopes = params.scopes;
    const installationId = params.installationId;
    const providerRepositoryId = params.providerRepositoryId;
    const providerBranch = params.providerBranch;
    const providerSilentMode = params.providerSilentMode;
    const providerRootDirectory = params.providerRootDirectory;
    const specification = params.specification;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    if (typeof runtime === "undefined") {
      throw new AppwriteException('Missing required parameter: "runtime"');
    }
    const apiPath = "/functions";
    const payload = {};
    if (typeof functionId !== "undefined") {
      payload["functionId"] = functionId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof runtime !== "undefined") {
      payload["runtime"] = runtime;
    }
    if (typeof execute !== "undefined") {
      payload["execute"] = execute;
    }
    if (typeof events !== "undefined") {
      payload["events"] = events;
    }
    if (typeof schedule !== "undefined") {
      payload["schedule"] = schedule;
    }
    if (typeof timeout !== "undefined") {
      payload["timeout"] = timeout;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof logging !== "undefined") {
      payload["logging"] = logging;
    }
    if (typeof entrypoint !== "undefined") {
      payload["entrypoint"] = entrypoint;
    }
    if (typeof commands !== "undefined") {
      payload["commands"] = commands;
    }
    if (typeof scopes !== "undefined") {
      payload["scopes"] = scopes;
    }
    if (typeof installationId !== "undefined") {
      payload["installationId"] = installationId;
    }
    if (typeof providerRepositoryId !== "undefined") {
      payload["providerRepositoryId"] = providerRepositoryId;
    }
    if (typeof providerBranch !== "undefined") {
      payload["providerBranch"] = providerBranch;
    }
    if (typeof providerSilentMode !== "undefined") {
      payload["providerSilentMode"] = providerSilentMode;
    }
    if (typeof providerRootDirectory !== "undefined") {
      payload["providerRootDirectory"] = providerRootDirectory;
    }
    if (typeof specification !== "undefined") {
      payload["specification"] = specification;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get a list of all runtimes that are currently active on your instance.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.RuntimeList>}
   */
  listRuntimes() {
    const apiPath = "/functions/runtimes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List allowed function specifications for this instance.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.SpecificationList>}
   */
  listSpecifications() {
    const apiPath = "/functions/specifications";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  get(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst
      };
    }
    const functionId = params.functionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  update(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        name: rest[0],
        runtime: rest[1],
        execute: rest[2],
        events: rest[3],
        schedule: rest[4],
        timeout: rest[5],
        enabled: rest[6],
        logging: rest[7],
        entrypoint: rest[8],
        commands: rest[9],
        scopes: rest[10],
        installationId: rest[11],
        providerRepositoryId: rest[12],
        providerBranch: rest[13],
        providerSilentMode: rest[14],
        providerRootDirectory: rest[15],
        specification: rest[16]
      };
    }
    const functionId = params.functionId;
    const name = params.name;
    const runtime = params.runtime;
    const execute = params.execute;
    const events = params.events;
    const schedule = params.schedule;
    const timeout = params.timeout;
    const enabled = params.enabled;
    const logging = params.logging;
    const entrypoint = params.entrypoint;
    const commands = params.commands;
    const scopes = params.scopes;
    const installationId = params.installationId;
    const providerRepositoryId = params.providerRepositoryId;
    const providerBranch = params.providerBranch;
    const providerSilentMode = params.providerSilentMode;
    const providerRootDirectory = params.providerRootDirectory;
    const specification = params.specification;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof runtime !== "undefined") {
      payload["runtime"] = runtime;
    }
    if (typeof execute !== "undefined") {
      payload["execute"] = execute;
    }
    if (typeof events !== "undefined") {
      payload["events"] = events;
    }
    if (typeof schedule !== "undefined") {
      payload["schedule"] = schedule;
    }
    if (typeof timeout !== "undefined") {
      payload["timeout"] = timeout;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof logging !== "undefined") {
      payload["logging"] = logging;
    }
    if (typeof entrypoint !== "undefined") {
      payload["entrypoint"] = entrypoint;
    }
    if (typeof commands !== "undefined") {
      payload["commands"] = commands;
    }
    if (typeof scopes !== "undefined") {
      payload["scopes"] = scopes;
    }
    if (typeof installationId !== "undefined") {
      payload["installationId"] = installationId;
    }
    if (typeof providerRepositoryId !== "undefined") {
      payload["providerRepositoryId"] = providerRepositoryId;
    }
    if (typeof providerBranch !== "undefined") {
      payload["providerBranch"] = providerBranch;
    }
    if (typeof providerSilentMode !== "undefined") {
      payload["providerSilentMode"] = providerSilentMode;
    }
    if (typeof providerRootDirectory !== "undefined") {
      payload["providerRootDirectory"] = providerRootDirectory;
    }
    if (typeof specification !== "undefined") {
      payload["specification"] = specification;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst
      };
    }
    const functionId = params.functionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  updateFunctionDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployment".replace("{functionId}", functionId);
    const payload = {};
    if (typeof deploymentId !== "undefined") {
      payload["deploymentId"] = deploymentId;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listDeployments(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        queries: rest[0],
        search: rest[1]
      };
    }
    const functionId = params.functionId;
    const queries = params.queries;
    const search = params.search;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}/deployments".replace("{functionId}", functionId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createDeployment(paramsOrFirst, ...rest) {
    let params;
    let onProgress;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
      onProgress = paramsOrFirst == null ? void 0 : paramsOrFirst.onProgress;
    } else {
      params = {
        functionId: paramsOrFirst,
        code: rest[0],
        activate: rest[1],
        entrypoint: rest[2],
        commands: rest[3]
      };
      onProgress = rest[4];
    }
    const functionId = params.functionId;
    const code = params.code;
    const activate = params.activate;
    const entrypoint = params.entrypoint;
    const commands = params.commands;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    if (typeof activate === "undefined") {
      throw new AppwriteException('Missing required parameter: "activate"');
    }
    const apiPath = "/functions/{functionId}/deployments".replace("{functionId}", functionId);
    const payload = {};
    if (typeof entrypoint !== "undefined") {
      payload["entrypoint"] = entrypoint;
    }
    if (typeof commands !== "undefined") {
      payload["commands"] = commands;
    }
    if (typeof code !== "undefined") {
      payload["code"] = code;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "multipart/form-data"
    };
    return this.client.chunkedUpload(
      "post",
      uri,
      apiHeaders,
      payload,
      onProgress
    );
  }
  createDuplicateDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0],
        buildId: rest[1]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    const buildId = params.buildId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/duplicate".replace("{functionId}", functionId);
    const payload = {};
    if (typeof deploymentId !== "undefined") {
      payload["deploymentId"] = deploymentId;
    }
    if (typeof buildId !== "undefined") {
      payload["buildId"] = buildId;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createTemplateDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        repository: rest[0],
        owner: rest[1],
        rootDirectory: rest[2],
        version: rest[3],
        activate: rest[4]
      };
    }
    const functionId = params.functionId;
    const repository = params.repository;
    const owner = params.owner;
    const rootDirectory = params.rootDirectory;
    const version = params.version;
    const activate = params.activate;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof repository === "undefined") {
      throw new AppwriteException('Missing required parameter: "repository"');
    }
    if (typeof owner === "undefined") {
      throw new AppwriteException('Missing required parameter: "owner"');
    }
    if (typeof rootDirectory === "undefined") {
      throw new AppwriteException('Missing required parameter: "rootDirectory"');
    }
    if (typeof version === "undefined") {
      throw new AppwriteException('Missing required parameter: "version"');
    }
    const apiPath = "/functions/{functionId}/deployments/template".replace("{functionId}", functionId);
    const payload = {};
    if (typeof repository !== "undefined") {
      payload["repository"] = repository;
    }
    if (typeof owner !== "undefined") {
      payload["owner"] = owner;
    }
    if (typeof rootDirectory !== "undefined") {
      payload["rootDirectory"] = rootDirectory;
    }
    if (typeof version !== "undefined") {
      payload["version"] = version;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createVcsDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        type: rest[0],
        reference: rest[1],
        activate: rest[2]
      };
    }
    const functionId = params.functionId;
    const type = params.type;
    const reference = params.reference;
    const activate = params.activate;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    if (typeof reference === "undefined") {
      throw new AppwriteException('Missing required parameter: "reference"');
    }
    const apiPath = "/functions/{functionId}/deployments/vcs".replace("{functionId}", functionId);
    const payload = {};
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    if (typeof reference !== "undefined") {
      payload["reference"] = reference;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  getDeploymentDownload(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0],
        type: rest[1]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    const type = params.type;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/{deploymentId}/download".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
    const payload = {};
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  updateDeploymentStatus(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/{deploymentId}/status".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listExecutions(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const functionId = params.functionId;
    const queries = params.queries;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}/executions".replace("{functionId}", functionId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createExecution(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        body: rest[0],
        async: rest[1],
        xpath: rest[2],
        method: rest[3],
        headers: rest[4],
        scheduledAt: rest[5]
      };
    }
    const functionId = params.functionId;
    const body = params.body;
    const async = params.async;
    const xpath = params.xpath;
    const method = params.method;
    const headers = params.headers;
    const scheduledAt = params.scheduledAt;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}/executions".replace("{functionId}", functionId);
    const payload = {};
    if (typeof body !== "undefined") {
      payload["body"] = body;
    }
    if (typeof async !== "undefined") {
      payload["async"] = async;
    }
    if (typeof xpath !== "undefined") {
      payload["path"] = xpath;
    }
    if (typeof method !== "undefined") {
      payload["method"] = method;
    }
    if (typeof headers !== "undefined") {
      payload["headers"] = headers;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getExecution(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        executionId: rest[0]
      };
    }
    const functionId = params.functionId;
    const executionId = params.executionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof executionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "executionId"');
    }
    const apiPath = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteExecution(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        executionId: rest[0]
      };
    }
    const functionId = params.functionId;
    const executionId = params.executionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof executionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "executionId"');
    }
    const apiPath = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listVariables(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst
      };
    }
    const functionId = params.functionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}/variables".replace("{functionId}", functionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        key: rest[0],
        value: rest[1],
        secret: rest[2]
      };
    }
    const functionId = params.functionId;
    const key = params.key;
    const value = params.value;
    const secret = params.secret;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof value === "undefined") {
      throw new AppwriteException('Missing required parameter: "value"');
    }
    const apiPath = "/functions/{functionId}/variables".replace("{functionId}", functionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        variableId: rest[0]
      };
    }
    const functionId = params.functionId;
    const variableId = params.variableId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        variableId: rest[0],
        key: rest[1],
        value: rest[2],
        secret: rest[3]
      };
    }
    const functionId = params.functionId;
    const variableId = params.variableId;
    const key = params.key;
    const value = params.value;
    const secret = params.secret;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        variableId: rest[0]
      };
    }
    const functionId = params.functionId;
    const variableId = params.variableId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/graphql.mjs
var Graphql = class {
  constructor(client) {
    this.client = client;
  }
  query(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "query" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        query: paramsOrFirst
      };
    }
    const query = params.query;
    if (typeof query === "undefined") {
      throw new AppwriteException('Missing required parameter: "query"');
    }
    const apiPath = "/graphql";
    const payload = {};
    if (typeof query !== "undefined") {
      payload["query"] = query;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "x-sdk-graphql": "true",
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  mutation(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "query" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        query: paramsOrFirst
      };
    }
    const query = params.query;
    if (typeof query === "undefined") {
      throw new AppwriteException('Missing required parameter: "query"');
    }
    const apiPath = "/graphql/mutation";
    const payload = {};
    if (typeof query !== "undefined") {
      payload["query"] = query;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "x-sdk-graphql": "true",
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/health.mjs
var Health = class {
  constructor(client) {
    this.client = client;
  }
  /**
   * Check the Appwrite HTTP server is up and responsive.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  get() {
    const apiPath = "/health";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite Antivirus server is up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthAntivirus>}
   */
  getAntivirus() {
    const apiPath = "/health/anti-virus";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite in-memory cache servers are up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getCache() {
    const apiPath = "/health/cache";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getCertificate(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        domain: paramsOrFirst
      };
    }
    const domain = params.domain;
    const apiPath = "/health/certificate";
    const payload = {};
    if (typeof domain !== "undefined") {
      payload["domain"] = domain;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite database servers are up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getDB() {
    const apiPath = "/health/db";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite pub-sub servers are up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getPubSub() {
    const apiPath = "/health/pubsub";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueBuilds(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/builds";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueCertificates(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/certificates";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueDatabases(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        name: paramsOrFirst,
        threshold: rest[0]
      };
    }
    const name = params.name;
    const threshold = params.threshold;
    const apiPath = "/health/queue/databases";
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueDeletes(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/deletes";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getFailedJobs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "name" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        name: paramsOrFirst,
        threshold: rest[0]
      };
    }
    const name = params.name;
    const threshold = params.threshold;
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/health/queue/failed/{name}".replace("{name}", name);
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueFunctions(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/functions";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueLogs(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/logs";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueMails(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/mails";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueMessaging(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/messaging";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueMigrations(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/migrations";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueStatsResources(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/stats-resources";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueUsage(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/stats-usage";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueWebhooks(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/webhooks";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite storage device is up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getStorage() {
    const apiPath = "/health/storage";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite local storage device is up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getStorageLocal() {
    const apiPath = "/health/storage/local";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthTime>}
   */
  getTime() {
    const apiPath = "/health/time";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/locale.mjs
var Locale = class {
  constructor(client) {
    this.client = client;
  }
  /**
   * Get the current user location based on IP. Returns an object with user country code, country name, continent name, continent code, ip address and suggested currency. You can use the locale header to get the data in a supported language.
   * 
   * ([IP Geolocation by DB-IP](https://db-ip.com))
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.Locale>}
   */
  get() {
    const apiPath = "/locale";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List of all locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.LocaleCodeList>}
   */
  listCodes() {
    const apiPath = "/locale/codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List of all continents. You can use the locale header to get the data in a supported language.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.ContinentList>}
   */
  listContinents() {
    const apiPath = "/locale/continents";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List of all countries. You can use the locale header to get the data in a supported language.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.CountryList>}
   */
  listCountries() {
    const apiPath = "/locale/countries";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List of all countries that are currently members of the EU. You can use the locale header to get the data in a supported language.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.CountryList>}
   */
  listCountriesEU() {
    const apiPath = "/locale/countries/eu";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List of all countries phone codes. You can use the locale header to get the data in a supported language.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.PhoneList>}
   */
  listCountriesPhones() {
    const apiPath = "/locale/countries/phones";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List of all currencies, including currency symbol, name, plural, and decimal digits for all major and minor currencies. You can use the locale header to get the data in a supported language.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.CurrencyList>}
   */
  listCurrencies() {
    const apiPath = "/locale/currencies";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List of all languages classified by ISO 639-1 including 2-letter code, name in English, and name in the respective language.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.LanguageList>}
   */
  listLanguages() {
    const apiPath = "/locale/languages";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/messaging.mjs
var Messaging = class {
  constructor(client) {
    this.client = client;
  }
  listMessages(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/messaging/messages";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createEmail(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        subject: rest[0],
        content: rest[1],
        topics: rest[2],
        users: rest[3],
        targets: rest[4],
        cc: rest[5],
        bcc: rest[6],
        attachments: rest[7],
        draft: rest[8],
        html: rest[9],
        scheduledAt: rest[10]
      };
    }
    const messageId = params.messageId;
    const subject = params.subject;
    const content = params.content;
    const topics = params.topics;
    const users = params.users;
    const targets = params.targets;
    const cc = params.cc;
    const bcc = params.bcc;
    const attachments = params.attachments;
    const draft = params.draft;
    const html = params.html;
    const scheduledAt = params.scheduledAt;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    if (typeof subject === "undefined") {
      throw new AppwriteException('Missing required parameter: "subject"');
    }
    if (typeof content === "undefined") {
      throw new AppwriteException('Missing required parameter: "content"');
    }
    const apiPath = "/messaging/messages/email";
    const payload = {};
    if (typeof messageId !== "undefined") {
      payload["messageId"] = messageId;
    }
    if (typeof subject !== "undefined") {
      payload["subject"] = subject;
    }
    if (typeof content !== "undefined") {
      payload["content"] = content;
    }
    if (typeof topics !== "undefined") {
      payload["topics"] = topics;
    }
    if (typeof users !== "undefined") {
      payload["users"] = users;
    }
    if (typeof targets !== "undefined") {
      payload["targets"] = targets;
    }
    if (typeof cc !== "undefined") {
      payload["cc"] = cc;
    }
    if (typeof bcc !== "undefined") {
      payload["bcc"] = bcc;
    }
    if (typeof attachments !== "undefined") {
      payload["attachments"] = attachments;
    }
    if (typeof draft !== "undefined") {
      payload["draft"] = draft;
    }
    if (typeof html !== "undefined") {
      payload["html"] = html;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEmail(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        topics: rest[0],
        users: rest[1],
        targets: rest[2],
        subject: rest[3],
        content: rest[4],
        draft: rest[5],
        html: rest[6],
        cc: rest[7],
        bcc: rest[8],
        scheduledAt: rest[9],
        attachments: rest[10]
      };
    }
    const messageId = params.messageId;
    const topics = params.topics;
    const users = params.users;
    const targets = params.targets;
    const subject = params.subject;
    const content = params.content;
    const draft = params.draft;
    const html = params.html;
    const cc = params.cc;
    const bcc = params.bcc;
    const scheduledAt = params.scheduledAt;
    const attachments = params.attachments;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/email/{messageId}".replace("{messageId}", messageId);
    const payload = {};
    if (typeof topics !== "undefined") {
      payload["topics"] = topics;
    }
    if (typeof users !== "undefined") {
      payload["users"] = users;
    }
    if (typeof targets !== "undefined") {
      payload["targets"] = targets;
    }
    if (typeof subject !== "undefined") {
      payload["subject"] = subject;
    }
    if (typeof content !== "undefined") {
      payload["content"] = content;
    }
    if (typeof draft !== "undefined") {
      payload["draft"] = draft;
    }
    if (typeof html !== "undefined") {
      payload["html"] = html;
    }
    if (typeof cc !== "undefined") {
      payload["cc"] = cc;
    }
    if (typeof bcc !== "undefined") {
      payload["bcc"] = bcc;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    if (typeof attachments !== "undefined") {
      payload["attachments"] = attachments;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createPush(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        title: rest[0],
        body: rest[1],
        topics: rest[2],
        users: rest[3],
        targets: rest[4],
        data: rest[5],
        action: rest[6],
        image: rest[7],
        icon: rest[8],
        sound: rest[9],
        color: rest[10],
        tag: rest[11],
        badge: rest[12],
        draft: rest[13],
        scheduledAt: rest[14],
        contentAvailable: rest[15],
        critical: rest[16],
        priority: rest[17]
      };
    }
    const messageId = params.messageId;
    const title = params.title;
    const body = params.body;
    const topics = params.topics;
    const users = params.users;
    const targets = params.targets;
    const data = params.data;
    const action = params.action;
    const image = params.image;
    const icon = params.icon;
    const sound = params.sound;
    const color = params.color;
    const tag = params.tag;
    const badge = params.badge;
    const draft = params.draft;
    const scheduledAt = params.scheduledAt;
    const contentAvailable = params.contentAvailable;
    const critical = params.critical;
    const priority = params.priority;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/push";
    const payload = {};
    if (typeof messageId !== "undefined") {
      payload["messageId"] = messageId;
    }
    if (typeof title !== "undefined") {
      payload["title"] = title;
    }
    if (typeof body !== "undefined") {
      payload["body"] = body;
    }
    if (typeof topics !== "undefined") {
      payload["topics"] = topics;
    }
    if (typeof users !== "undefined") {
      payload["users"] = users;
    }
    if (typeof targets !== "undefined") {
      payload["targets"] = targets;
    }
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof action !== "undefined") {
      payload["action"] = action;
    }
    if (typeof image !== "undefined") {
      payload["image"] = image;
    }
    if (typeof icon !== "undefined") {
      payload["icon"] = icon;
    }
    if (typeof sound !== "undefined") {
      payload["sound"] = sound;
    }
    if (typeof color !== "undefined") {
      payload["color"] = color;
    }
    if (typeof tag !== "undefined") {
      payload["tag"] = tag;
    }
    if (typeof badge !== "undefined") {
      payload["badge"] = badge;
    }
    if (typeof draft !== "undefined") {
      payload["draft"] = draft;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    if (typeof contentAvailable !== "undefined") {
      payload["contentAvailable"] = contentAvailable;
    }
    if (typeof critical !== "undefined") {
      payload["critical"] = critical;
    }
    if (typeof priority !== "undefined") {
      payload["priority"] = priority;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePush(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        topics: rest[0],
        users: rest[1],
        targets: rest[2],
        title: rest[3],
        body: rest[4],
        data: rest[5],
        action: rest[6],
        image: rest[7],
        icon: rest[8],
        sound: rest[9],
        color: rest[10],
        tag: rest[11],
        badge: rest[12],
        draft: rest[13],
        scheduledAt: rest[14],
        contentAvailable: rest[15],
        critical: rest[16],
        priority: rest[17]
      };
    }
    const messageId = params.messageId;
    const topics = params.topics;
    const users = params.users;
    const targets = params.targets;
    const title = params.title;
    const body = params.body;
    const data = params.data;
    const action = params.action;
    const image = params.image;
    const icon = params.icon;
    const sound = params.sound;
    const color = params.color;
    const tag = params.tag;
    const badge = params.badge;
    const draft = params.draft;
    const scheduledAt = params.scheduledAt;
    const contentAvailable = params.contentAvailable;
    const critical = params.critical;
    const priority = params.priority;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/push/{messageId}".replace("{messageId}", messageId);
    const payload = {};
    if (typeof topics !== "undefined") {
      payload["topics"] = topics;
    }
    if (typeof users !== "undefined") {
      payload["users"] = users;
    }
    if (typeof targets !== "undefined") {
      payload["targets"] = targets;
    }
    if (typeof title !== "undefined") {
      payload["title"] = title;
    }
    if (typeof body !== "undefined") {
      payload["body"] = body;
    }
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof action !== "undefined") {
      payload["action"] = action;
    }
    if (typeof image !== "undefined") {
      payload["image"] = image;
    }
    if (typeof icon !== "undefined") {
      payload["icon"] = icon;
    }
    if (typeof sound !== "undefined") {
      payload["sound"] = sound;
    }
    if (typeof color !== "undefined") {
      payload["color"] = color;
    }
    if (typeof tag !== "undefined") {
      payload["tag"] = tag;
    }
    if (typeof badge !== "undefined") {
      payload["badge"] = badge;
    }
    if (typeof draft !== "undefined") {
      payload["draft"] = draft;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    if (typeof contentAvailable !== "undefined") {
      payload["contentAvailable"] = contentAvailable;
    }
    if (typeof critical !== "undefined") {
      payload["critical"] = critical;
    }
    if (typeof priority !== "undefined") {
      payload["priority"] = priority;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createSms(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        content: rest[0],
        topics: rest[1],
        users: rest[2],
        targets: rest[3],
        draft: rest[4],
        scheduledAt: rest[5]
      };
    }
    const messageId = params.messageId;
    const content = params.content;
    const topics = params.topics;
    const users = params.users;
    const targets = params.targets;
    const draft = params.draft;
    const scheduledAt = params.scheduledAt;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    if (typeof content === "undefined") {
      throw new AppwriteException('Missing required parameter: "content"');
    }
    const apiPath = "/messaging/messages/sms";
    const payload = {};
    if (typeof messageId !== "undefined") {
      payload["messageId"] = messageId;
    }
    if (typeof content !== "undefined") {
      payload["content"] = content;
    }
    if (typeof topics !== "undefined") {
      payload["topics"] = topics;
    }
    if (typeof users !== "undefined") {
      payload["users"] = users;
    }
    if (typeof targets !== "undefined") {
      payload["targets"] = targets;
    }
    if (typeof draft !== "undefined") {
      payload["draft"] = draft;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createSMS(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        content: rest[0],
        topics: rest[1],
        users: rest[2],
        targets: rest[3],
        draft: rest[4],
        scheduledAt: rest[5]
      };
    }
    const messageId = params.messageId;
    const content = params.content;
    const topics = params.topics;
    const users = params.users;
    const targets = params.targets;
    const draft = params.draft;
    const scheduledAt = params.scheduledAt;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    if (typeof content === "undefined") {
      throw new AppwriteException('Missing required parameter: "content"');
    }
    const apiPath = "/messaging/messages/sms";
    const payload = {};
    if (typeof messageId !== "undefined") {
      payload["messageId"] = messageId;
    }
    if (typeof content !== "undefined") {
      payload["content"] = content;
    }
    if (typeof topics !== "undefined") {
      payload["topics"] = topics;
    }
    if (typeof users !== "undefined") {
      payload["users"] = users;
    }
    if (typeof targets !== "undefined") {
      payload["targets"] = targets;
    }
    if (typeof draft !== "undefined") {
      payload["draft"] = draft;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateSms(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        topics: rest[0],
        users: rest[1],
        targets: rest[2],
        content: rest[3],
        draft: rest[4],
        scheduledAt: rest[5]
      };
    }
    const messageId = params.messageId;
    const topics = params.topics;
    const users = params.users;
    const targets = params.targets;
    const content = params.content;
    const draft = params.draft;
    const scheduledAt = params.scheduledAt;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/sms/{messageId}".replace("{messageId}", messageId);
    const payload = {};
    if (typeof topics !== "undefined") {
      payload["topics"] = topics;
    }
    if (typeof users !== "undefined") {
      payload["users"] = users;
    }
    if (typeof targets !== "undefined") {
      payload["targets"] = targets;
    }
    if (typeof content !== "undefined") {
      payload["content"] = content;
    }
    if (typeof draft !== "undefined") {
      payload["draft"] = draft;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updateSMS(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        topics: rest[0],
        users: rest[1],
        targets: rest[2],
        content: rest[3],
        draft: rest[4],
        scheduledAt: rest[5]
      };
    }
    const messageId = params.messageId;
    const topics = params.topics;
    const users = params.users;
    const targets = params.targets;
    const content = params.content;
    const draft = params.draft;
    const scheduledAt = params.scheduledAt;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/sms/{messageId}".replace("{messageId}", messageId);
    const payload = {};
    if (typeof topics !== "undefined") {
      payload["topics"] = topics;
    }
    if (typeof users !== "undefined") {
      payload["users"] = users;
    }
    if (typeof targets !== "undefined") {
      payload["targets"] = targets;
    }
    if (typeof content !== "undefined") {
      payload["content"] = content;
    }
    if (typeof draft !== "undefined") {
      payload["draft"] = draft;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  getMessage(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst
      };
    }
    const messageId = params.messageId;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/{messageId}".replace("{messageId}", messageId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst
      };
    }
    const messageId = params.messageId;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/{messageId}".replace("{messageId}", messageId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listMessageLogs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const messageId = params.messageId;
    const queries = params.queries;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/{messageId}/logs".replace("{messageId}", messageId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  listTargets(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        messageId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const messageId = params.messageId;
    const queries = params.queries;
    if (typeof messageId === "undefined") {
      throw new AppwriteException('Missing required parameter: "messageId"');
    }
    const apiPath = "/messaging/messages/{messageId}/targets".replace("{messageId}", messageId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  listProviders(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/messaging/providers";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createApnsProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        authKey: rest[1],
        authKeyId: rest[2],
        teamId: rest[3],
        bundleId: rest[4],
        sandbox: rest[5],
        enabled: rest[6]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const authKey = params.authKey;
    const authKeyId = params.authKeyId;
    const teamId = params.teamId;
    const bundleId = params.bundleId;
    const sandbox = params.sandbox;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/apns";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof authKey !== "undefined") {
      payload["authKey"] = authKey;
    }
    if (typeof authKeyId !== "undefined") {
      payload["authKeyId"] = authKeyId;
    }
    if (typeof teamId !== "undefined") {
      payload["teamId"] = teamId;
    }
    if (typeof bundleId !== "undefined") {
      payload["bundleId"] = bundleId;
    }
    if (typeof sandbox !== "undefined") {
      payload["sandbox"] = sandbox;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createAPNSProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        authKey: rest[1],
        authKeyId: rest[2],
        teamId: rest[3],
        bundleId: rest[4],
        sandbox: rest[5],
        enabled: rest[6]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const authKey = params.authKey;
    const authKeyId = params.authKeyId;
    const teamId = params.teamId;
    const bundleId = params.bundleId;
    const sandbox = params.sandbox;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/apns";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof authKey !== "undefined") {
      payload["authKey"] = authKey;
    }
    if (typeof authKeyId !== "undefined") {
      payload["authKeyId"] = authKeyId;
    }
    if (typeof teamId !== "undefined") {
      payload["teamId"] = teamId;
    }
    if (typeof bundleId !== "undefined") {
      payload["bundleId"] = bundleId;
    }
    if (typeof sandbox !== "undefined") {
      payload["sandbox"] = sandbox;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateApnsProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        authKey: rest[2],
        authKeyId: rest[3],
        teamId: rest[4],
        bundleId: rest[5],
        sandbox: rest[6]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const authKey = params.authKey;
    const authKeyId = params.authKeyId;
    const teamId = params.teamId;
    const bundleId = params.bundleId;
    const sandbox = params.sandbox;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/apns/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof authKey !== "undefined") {
      payload["authKey"] = authKey;
    }
    if (typeof authKeyId !== "undefined") {
      payload["authKeyId"] = authKeyId;
    }
    if (typeof teamId !== "undefined") {
      payload["teamId"] = teamId;
    }
    if (typeof bundleId !== "undefined") {
      payload["bundleId"] = bundleId;
    }
    if (typeof sandbox !== "undefined") {
      payload["sandbox"] = sandbox;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updateAPNSProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        authKey: rest[2],
        authKeyId: rest[3],
        teamId: rest[4],
        bundleId: rest[5],
        sandbox: rest[6]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const authKey = params.authKey;
    const authKeyId = params.authKeyId;
    const teamId = params.teamId;
    const bundleId = params.bundleId;
    const sandbox = params.sandbox;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/apns/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof authKey !== "undefined") {
      payload["authKey"] = authKey;
    }
    if (typeof authKeyId !== "undefined") {
      payload["authKeyId"] = authKeyId;
    }
    if (typeof teamId !== "undefined") {
      payload["teamId"] = teamId;
    }
    if (typeof bundleId !== "undefined") {
      payload["bundleId"] = bundleId;
    }
    if (typeof sandbox !== "undefined") {
      payload["sandbox"] = sandbox;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createFcmProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        serviceAccountJSON: rest[1],
        enabled: rest[2]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const serviceAccountJSON = params.serviceAccountJSON;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/fcm";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof serviceAccountJSON !== "undefined") {
      payload["serviceAccountJSON"] = serviceAccountJSON;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createFCMProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        serviceAccountJSON: rest[1],
        enabled: rest[2]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const serviceAccountJSON = params.serviceAccountJSON;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/fcm";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof serviceAccountJSON !== "undefined") {
      payload["serviceAccountJSON"] = serviceAccountJSON;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateFcmProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        serviceAccountJSON: rest[2]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const serviceAccountJSON = params.serviceAccountJSON;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/fcm/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof serviceAccountJSON !== "undefined") {
      payload["serviceAccountJSON"] = serviceAccountJSON;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updateFCMProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        serviceAccountJSON: rest[2]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const serviceAccountJSON = params.serviceAccountJSON;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/fcm/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof serviceAccountJSON !== "undefined") {
      payload["serviceAccountJSON"] = serviceAccountJSON;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createMailgunProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        apiKey: rest[1],
        domain: rest[2],
        isEuRegion: rest[3],
        fromName: rest[4],
        fromEmail: rest[5],
        replyToName: rest[6],
        replyToEmail: rest[7],
        enabled: rest[8]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const apiKey = params.apiKey;
    const domain = params.domain;
    const isEuRegion = params.isEuRegion;
    const fromName = params.fromName;
    const fromEmail = params.fromEmail;
    const replyToName = params.replyToName;
    const replyToEmail = params.replyToEmail;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/mailgun";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof domain !== "undefined") {
      payload["domain"] = domain;
    }
    if (typeof isEuRegion !== "undefined") {
      payload["isEuRegion"] = isEuRegion;
    }
    if (typeof fromName !== "undefined") {
      payload["fromName"] = fromName;
    }
    if (typeof fromEmail !== "undefined") {
      payload["fromEmail"] = fromEmail;
    }
    if (typeof replyToName !== "undefined") {
      payload["replyToName"] = replyToName;
    }
    if (typeof replyToEmail !== "undefined") {
      payload["replyToEmail"] = replyToEmail;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMailgunProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        apiKey: rest[1],
        domain: rest[2],
        isEuRegion: rest[3],
        enabled: rest[4],
        fromName: rest[5],
        fromEmail: rest[6],
        replyToName: rest[7],
        replyToEmail: rest[8]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const apiKey = params.apiKey;
    const domain = params.domain;
    const isEuRegion = params.isEuRegion;
    const enabled = params.enabled;
    const fromName = params.fromName;
    const fromEmail = params.fromEmail;
    const replyToName = params.replyToName;
    const replyToEmail = params.replyToEmail;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/mailgun/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof domain !== "undefined") {
      payload["domain"] = domain;
    }
    if (typeof isEuRegion !== "undefined") {
      payload["isEuRegion"] = isEuRegion;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof fromName !== "undefined") {
      payload["fromName"] = fromName;
    }
    if (typeof fromEmail !== "undefined") {
      payload["fromEmail"] = fromEmail;
    }
    if (typeof replyToName !== "undefined") {
      payload["replyToName"] = replyToName;
    }
    if (typeof replyToEmail !== "undefined") {
      payload["replyToEmail"] = replyToEmail;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createMsg91Provider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        templateId: rest[1],
        senderId: rest[2],
        authKey: rest[3],
        enabled: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const templateId = params.templateId;
    const senderId = params.senderId;
    const authKey = params.authKey;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/msg91";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof templateId !== "undefined") {
      payload["templateId"] = templateId;
    }
    if (typeof senderId !== "undefined") {
      payload["senderId"] = senderId;
    }
    if (typeof authKey !== "undefined") {
      payload["authKey"] = authKey;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMsg91Provider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        templateId: rest[2],
        senderId: rest[3],
        authKey: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const templateId = params.templateId;
    const senderId = params.senderId;
    const authKey = params.authKey;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/msg91/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof templateId !== "undefined") {
      payload["templateId"] = templateId;
    }
    if (typeof senderId !== "undefined") {
      payload["senderId"] = senderId;
    }
    if (typeof authKey !== "undefined") {
      payload["authKey"] = authKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createSendgridProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        apiKey: rest[1],
        fromName: rest[2],
        fromEmail: rest[3],
        replyToName: rest[4],
        replyToEmail: rest[5],
        enabled: rest[6]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const apiKey = params.apiKey;
    const fromName = params.fromName;
    const fromEmail = params.fromEmail;
    const replyToName = params.replyToName;
    const replyToEmail = params.replyToEmail;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/sendgrid";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof fromName !== "undefined") {
      payload["fromName"] = fromName;
    }
    if (typeof fromEmail !== "undefined") {
      payload["fromEmail"] = fromEmail;
    }
    if (typeof replyToName !== "undefined") {
      payload["replyToName"] = replyToName;
    }
    if (typeof replyToEmail !== "undefined") {
      payload["replyToEmail"] = replyToEmail;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateSendgridProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        apiKey: rest[2],
        fromName: rest[3],
        fromEmail: rest[4],
        replyToName: rest[5],
        replyToEmail: rest[6]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const apiKey = params.apiKey;
    const fromName = params.fromName;
    const fromEmail = params.fromEmail;
    const replyToName = params.replyToName;
    const replyToEmail = params.replyToEmail;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/sendgrid/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof fromName !== "undefined") {
      payload["fromName"] = fromName;
    }
    if (typeof fromEmail !== "undefined") {
      payload["fromEmail"] = fromEmail;
    }
    if (typeof replyToName !== "undefined") {
      payload["replyToName"] = replyToName;
    }
    if (typeof replyToEmail !== "undefined") {
      payload["replyToEmail"] = replyToEmail;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createSmtpProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        host: rest[1],
        port: rest[2],
        username: rest[3],
        password: rest[4],
        encryption: rest[5],
        autoTLS: rest[6],
        mailer: rest[7],
        fromName: rest[8],
        fromEmail: rest[9],
        replyToName: rest[10],
        replyToEmail: rest[11],
        enabled: rest[12]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const host = params.host;
    const port = params.port;
    const username = params.username;
    const password = params.password;
    const encryption = params.encryption;
    const autoTLS = params.autoTLS;
    const mailer = params.mailer;
    const fromName = params.fromName;
    const fromEmail = params.fromEmail;
    const replyToName = params.replyToName;
    const replyToEmail = params.replyToEmail;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    if (typeof host === "undefined") {
      throw new AppwriteException('Missing required parameter: "host"');
    }
    const apiPath = "/messaging/providers/smtp";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof host !== "undefined") {
      payload["host"] = host;
    }
    if (typeof port !== "undefined") {
      payload["port"] = port;
    }
    if (typeof username !== "undefined") {
      payload["username"] = username;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof encryption !== "undefined") {
      payload["encryption"] = encryption;
    }
    if (typeof autoTLS !== "undefined") {
      payload["autoTLS"] = autoTLS;
    }
    if (typeof mailer !== "undefined") {
      payload["mailer"] = mailer;
    }
    if (typeof fromName !== "undefined") {
      payload["fromName"] = fromName;
    }
    if (typeof fromEmail !== "undefined") {
      payload["fromEmail"] = fromEmail;
    }
    if (typeof replyToName !== "undefined") {
      payload["replyToName"] = replyToName;
    }
    if (typeof replyToEmail !== "undefined") {
      payload["replyToEmail"] = replyToEmail;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createSMTPProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        host: rest[1],
        port: rest[2],
        username: rest[3],
        password: rest[4],
        encryption: rest[5],
        autoTLS: rest[6],
        mailer: rest[7],
        fromName: rest[8],
        fromEmail: rest[9],
        replyToName: rest[10],
        replyToEmail: rest[11],
        enabled: rest[12]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const host = params.host;
    const port = params.port;
    const username = params.username;
    const password = params.password;
    const encryption = params.encryption;
    const autoTLS = params.autoTLS;
    const mailer = params.mailer;
    const fromName = params.fromName;
    const fromEmail = params.fromEmail;
    const replyToName = params.replyToName;
    const replyToEmail = params.replyToEmail;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    if (typeof host === "undefined") {
      throw new AppwriteException('Missing required parameter: "host"');
    }
    const apiPath = "/messaging/providers/smtp";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof host !== "undefined") {
      payload["host"] = host;
    }
    if (typeof port !== "undefined") {
      payload["port"] = port;
    }
    if (typeof username !== "undefined") {
      payload["username"] = username;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof encryption !== "undefined") {
      payload["encryption"] = encryption;
    }
    if (typeof autoTLS !== "undefined") {
      payload["autoTLS"] = autoTLS;
    }
    if (typeof mailer !== "undefined") {
      payload["mailer"] = mailer;
    }
    if (typeof fromName !== "undefined") {
      payload["fromName"] = fromName;
    }
    if (typeof fromEmail !== "undefined") {
      payload["fromEmail"] = fromEmail;
    }
    if (typeof replyToName !== "undefined") {
      payload["replyToName"] = replyToName;
    }
    if (typeof replyToEmail !== "undefined") {
      payload["replyToEmail"] = replyToEmail;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateSmtpProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        host: rest[1],
        port: rest[2],
        username: rest[3],
        password: rest[4],
        encryption: rest[5],
        autoTLS: rest[6],
        mailer: rest[7],
        fromName: rest[8],
        fromEmail: rest[9],
        replyToName: rest[10],
        replyToEmail: rest[11],
        enabled: rest[12]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const host = params.host;
    const port = params.port;
    const username = params.username;
    const password = params.password;
    const encryption = params.encryption;
    const autoTLS = params.autoTLS;
    const mailer = params.mailer;
    const fromName = params.fromName;
    const fromEmail = params.fromEmail;
    const replyToName = params.replyToName;
    const replyToEmail = params.replyToEmail;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/smtp/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof host !== "undefined") {
      payload["host"] = host;
    }
    if (typeof port !== "undefined") {
      payload["port"] = port;
    }
    if (typeof username !== "undefined") {
      payload["username"] = username;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof encryption !== "undefined") {
      payload["encryption"] = encryption;
    }
    if (typeof autoTLS !== "undefined") {
      payload["autoTLS"] = autoTLS;
    }
    if (typeof mailer !== "undefined") {
      payload["mailer"] = mailer;
    }
    if (typeof fromName !== "undefined") {
      payload["fromName"] = fromName;
    }
    if (typeof fromEmail !== "undefined") {
      payload["fromEmail"] = fromEmail;
    }
    if (typeof replyToName !== "undefined") {
      payload["replyToName"] = replyToName;
    }
    if (typeof replyToEmail !== "undefined") {
      payload["replyToEmail"] = replyToEmail;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updateSMTPProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        host: rest[1],
        port: rest[2],
        username: rest[3],
        password: rest[4],
        encryption: rest[5],
        autoTLS: rest[6],
        mailer: rest[7],
        fromName: rest[8],
        fromEmail: rest[9],
        replyToName: rest[10],
        replyToEmail: rest[11],
        enabled: rest[12]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const host = params.host;
    const port = params.port;
    const username = params.username;
    const password = params.password;
    const encryption = params.encryption;
    const autoTLS = params.autoTLS;
    const mailer = params.mailer;
    const fromName = params.fromName;
    const fromEmail = params.fromEmail;
    const replyToName = params.replyToName;
    const replyToEmail = params.replyToEmail;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/smtp/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof host !== "undefined") {
      payload["host"] = host;
    }
    if (typeof port !== "undefined") {
      payload["port"] = port;
    }
    if (typeof username !== "undefined") {
      payload["username"] = username;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof encryption !== "undefined") {
      payload["encryption"] = encryption;
    }
    if (typeof autoTLS !== "undefined") {
      payload["autoTLS"] = autoTLS;
    }
    if (typeof mailer !== "undefined") {
      payload["mailer"] = mailer;
    }
    if (typeof fromName !== "undefined") {
      payload["fromName"] = fromName;
    }
    if (typeof fromEmail !== "undefined") {
      payload["fromEmail"] = fromEmail;
    }
    if (typeof replyToName !== "undefined") {
      payload["replyToName"] = replyToName;
    }
    if (typeof replyToEmail !== "undefined") {
      payload["replyToEmail"] = replyToEmail;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createTelesignProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        from: rest[1],
        customerId: rest[2],
        apiKey: rest[3],
        enabled: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const from = params.from;
    const customerId = params.customerId;
    const apiKey = params.apiKey;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/telesign";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof from !== "undefined") {
      payload["from"] = from;
    }
    if (typeof customerId !== "undefined") {
      payload["customerId"] = customerId;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateTelesignProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        customerId: rest[2],
        apiKey: rest[3],
        from: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const customerId = params.customerId;
    const apiKey = params.apiKey;
    const from = params.from;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/telesign/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof customerId !== "undefined") {
      payload["customerId"] = customerId;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof from !== "undefined") {
      payload["from"] = from;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createTextmagicProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        from: rest[1],
        username: rest[2],
        apiKey: rest[3],
        enabled: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const from = params.from;
    const username = params.username;
    const apiKey = params.apiKey;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/textmagic";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof from !== "undefined") {
      payload["from"] = from;
    }
    if (typeof username !== "undefined") {
      payload["username"] = username;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateTextmagicProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        username: rest[2],
        apiKey: rest[3],
        from: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const username = params.username;
    const apiKey = params.apiKey;
    const from = params.from;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/textmagic/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof username !== "undefined") {
      payload["username"] = username;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof from !== "undefined") {
      payload["from"] = from;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createTwilioProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        from: rest[1],
        accountSid: rest[2],
        authToken: rest[3],
        enabled: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const from = params.from;
    const accountSid = params.accountSid;
    const authToken = params.authToken;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/twilio";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof from !== "undefined") {
      payload["from"] = from;
    }
    if (typeof accountSid !== "undefined") {
      payload["accountSid"] = accountSid;
    }
    if (typeof authToken !== "undefined") {
      payload["authToken"] = authToken;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateTwilioProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        accountSid: rest[2],
        authToken: rest[3],
        from: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const accountSid = params.accountSid;
    const authToken = params.authToken;
    const from = params.from;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/twilio/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof accountSid !== "undefined") {
      payload["accountSid"] = accountSid;
    }
    if (typeof authToken !== "undefined") {
      payload["authToken"] = authToken;
    }
    if (typeof from !== "undefined") {
      payload["from"] = from;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createVonageProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        from: rest[1],
        apiKey: rest[2],
        apiSecret: rest[3],
        enabled: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const from = params.from;
    const apiKey = params.apiKey;
    const apiSecret = params.apiSecret;
    const enabled = params.enabled;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/providers/vonage";
    const payload = {};
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof from !== "undefined") {
      payload["from"] = from;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof apiSecret !== "undefined") {
      payload["apiSecret"] = apiSecret;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateVonageProvider(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1],
        apiKey: rest[2],
        apiSecret: rest[3],
        from: rest[4]
      };
    }
    const providerId = params.providerId;
    const name = params.name;
    const enabled = params.enabled;
    const apiKey = params.apiKey;
    const apiSecret = params.apiSecret;
    const from = params.from;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/vonage/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof apiKey !== "undefined") {
      payload["apiKey"] = apiKey;
    }
    if (typeof apiSecret !== "undefined") {
      payload["apiSecret"] = apiSecret;
    }
    if (typeof from !== "undefined") {
      payload["from"] = from;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  getProvider(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst
      };
    }
    const providerId = params.providerId;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteProvider(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst
      };
    }
    const providerId = params.providerId;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/{providerId}".replace("{providerId}", providerId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listProviderLogs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        providerId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const providerId = params.providerId;
    const queries = params.queries;
    if (typeof providerId === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerId"');
    }
    const apiPath = "/messaging/providers/{providerId}/logs".replace("{providerId}", providerId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  listSubscriberLogs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        subscriberId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const subscriberId = params.subscriberId;
    const queries = params.queries;
    if (typeof subscriberId === "undefined") {
      throw new AppwriteException('Missing required parameter: "subscriberId"');
    }
    const apiPath = "/messaging/subscribers/{subscriberId}/logs".replace("{subscriberId}", subscriberId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  listTopics(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/messaging/topics";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createTopic(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst,
        name: rest[0],
        subscribe: rest[1]
      };
    }
    const topicId = params.topicId;
    const name = params.name;
    const subscribe = params.subscribe;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/messaging/topics";
    const payload = {};
    if (typeof topicId !== "undefined") {
      payload["topicId"] = topicId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof subscribe !== "undefined") {
      payload["subscribe"] = subscribe;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getTopic(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst
      };
    }
    const topicId = params.topicId;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateTopic(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst,
        name: rest[0],
        subscribe: rest[1]
      };
    }
    const topicId = params.topicId;
    const name = params.name;
    const subscribe = params.subscribe;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof subscribe !== "undefined") {
      payload["subscribe"] = subscribe;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteTopic(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst
      };
    }
    const topicId = params.topicId;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listTopicLogs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const topicId = params.topicId;
    const queries = params.queries;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    const apiPath = "/messaging/topics/{topicId}/logs".replace("{topicId}", topicId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  listSubscribers(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst,
        queries: rest[0],
        search: rest[1]
      };
    }
    const topicId = params.topicId;
    const queries = params.queries;
    const search = params.search;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    const apiPath = "/messaging/topics/{topicId}/subscribers".replace("{topicId}", topicId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createSubscriber(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst,
        subscriberId: rest[0],
        targetId: rest[1]
      };
    }
    const topicId = params.topicId;
    const subscriberId = params.subscriberId;
    const targetId = params.targetId;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    if (typeof subscriberId === "undefined") {
      throw new AppwriteException('Missing required parameter: "subscriberId"');
    }
    if (typeof targetId === "undefined") {
      throw new AppwriteException('Missing required parameter: "targetId"');
    }
    const apiPath = "/messaging/topics/{topicId}/subscribers".replace("{topicId}", topicId);
    const payload = {};
    if (typeof subscriberId !== "undefined") {
      payload["subscriberId"] = subscriberId;
    }
    if (typeof targetId !== "undefined") {
      payload["targetId"] = targetId;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getSubscriber(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst,
        subscriberId: rest[0]
      };
    }
    const topicId = params.topicId;
    const subscriberId = params.subscriberId;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    if (typeof subscriberId === "undefined") {
      throw new AppwriteException('Missing required parameter: "subscriberId"');
    }
    const apiPath = "/messaging/topics/{topicId}/subscribers/{subscriberId}".replace("{topicId}", topicId).replace("{subscriberId}", subscriberId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteSubscriber(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        topicId: paramsOrFirst,
        subscriberId: rest[0]
      };
    }
    const topicId = params.topicId;
    const subscriberId = params.subscriberId;
    if (typeof topicId === "undefined") {
      throw new AppwriteException('Missing required parameter: "topicId"');
    }
    if (typeof subscriberId === "undefined") {
      throw new AppwriteException('Missing required parameter: "subscriberId"');
    }
    const apiPath = "/messaging/topics/{topicId}/subscribers/{subscriberId}".replace("{topicId}", topicId).replace("{subscriberId}", subscriberId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/sites.mjs
var Sites = class {
  constructor(client) {
    this.client = client;
  }
  list(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/sites";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        name: rest[0],
        framework: rest[1],
        buildRuntime: rest[2],
        enabled: rest[3],
        logging: rest[4],
        timeout: rest[5],
        installCommand: rest[6],
        buildCommand: rest[7],
        outputDirectory: rest[8],
        adapter: rest[9],
        installationId: rest[10],
        fallbackFile: rest[11],
        providerRepositoryId: rest[12],
        providerBranch: rest[13],
        providerSilentMode: rest[14],
        providerRootDirectory: rest[15],
        specification: rest[16]
      };
    }
    const siteId = params.siteId;
    const name = params.name;
    const framework = params.framework;
    const buildRuntime = params.buildRuntime;
    const enabled = params.enabled;
    const logging = params.logging;
    const timeout = params.timeout;
    const installCommand = params.installCommand;
    const buildCommand = params.buildCommand;
    const outputDirectory = params.outputDirectory;
    const adapter = params.adapter;
    const installationId = params.installationId;
    const fallbackFile = params.fallbackFile;
    const providerRepositoryId = params.providerRepositoryId;
    const providerBranch = params.providerBranch;
    const providerSilentMode = params.providerSilentMode;
    const providerRootDirectory = params.providerRootDirectory;
    const specification = params.specification;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    if (typeof framework === "undefined") {
      throw new AppwriteException('Missing required parameter: "framework"');
    }
    if (typeof buildRuntime === "undefined") {
      throw new AppwriteException('Missing required parameter: "buildRuntime"');
    }
    const apiPath = "/sites";
    const payload = {};
    if (typeof siteId !== "undefined") {
      payload["siteId"] = siteId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof framework !== "undefined") {
      payload["framework"] = framework;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof logging !== "undefined") {
      payload["logging"] = logging;
    }
    if (typeof timeout !== "undefined") {
      payload["timeout"] = timeout;
    }
    if (typeof installCommand !== "undefined") {
      payload["installCommand"] = installCommand;
    }
    if (typeof buildCommand !== "undefined") {
      payload["buildCommand"] = buildCommand;
    }
    if (typeof outputDirectory !== "undefined") {
      payload["outputDirectory"] = outputDirectory;
    }
    if (typeof buildRuntime !== "undefined") {
      payload["buildRuntime"] = buildRuntime;
    }
    if (typeof adapter !== "undefined") {
      payload["adapter"] = adapter;
    }
    if (typeof installationId !== "undefined") {
      payload["installationId"] = installationId;
    }
    if (typeof fallbackFile !== "undefined") {
      payload["fallbackFile"] = fallbackFile;
    }
    if (typeof providerRepositoryId !== "undefined") {
      payload["providerRepositoryId"] = providerRepositoryId;
    }
    if (typeof providerBranch !== "undefined") {
      payload["providerBranch"] = providerBranch;
    }
    if (typeof providerSilentMode !== "undefined") {
      payload["providerSilentMode"] = providerSilentMode;
    }
    if (typeof providerRootDirectory !== "undefined") {
      payload["providerRootDirectory"] = providerRootDirectory;
    }
    if (typeof specification !== "undefined") {
      payload["specification"] = specification;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get a list of all frameworks that are currently available on the server instance.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.FrameworkList>}
   */
  listFrameworks() {
    const apiPath = "/sites/frameworks";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List allowed site specifications for this instance.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.SpecificationList>}
   */
  listSpecifications() {
    const apiPath = "/sites/specifications";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  get(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst
      };
    }
    const siteId = params.siteId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    const apiPath = "/sites/{siteId}".replace("{siteId}", siteId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  update(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        name: rest[0],
        framework: rest[1],
        enabled: rest[2],
        logging: rest[3],
        timeout: rest[4],
        installCommand: rest[5],
        buildCommand: rest[6],
        outputDirectory: rest[7],
        buildRuntime: rest[8],
        adapter: rest[9],
        fallbackFile: rest[10],
        installationId: rest[11],
        providerRepositoryId: rest[12],
        providerBranch: rest[13],
        providerSilentMode: rest[14],
        providerRootDirectory: rest[15],
        specification: rest[16]
      };
    }
    const siteId = params.siteId;
    const name = params.name;
    const framework = params.framework;
    const enabled = params.enabled;
    const logging = params.logging;
    const timeout = params.timeout;
    const installCommand = params.installCommand;
    const buildCommand = params.buildCommand;
    const outputDirectory = params.outputDirectory;
    const buildRuntime = params.buildRuntime;
    const adapter = params.adapter;
    const fallbackFile = params.fallbackFile;
    const installationId = params.installationId;
    const providerRepositoryId = params.providerRepositoryId;
    const providerBranch = params.providerBranch;
    const providerSilentMode = params.providerSilentMode;
    const providerRootDirectory = params.providerRootDirectory;
    const specification = params.specification;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    if (typeof framework === "undefined") {
      throw new AppwriteException('Missing required parameter: "framework"');
    }
    const apiPath = "/sites/{siteId}".replace("{siteId}", siteId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof framework !== "undefined") {
      payload["framework"] = framework;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof logging !== "undefined") {
      payload["logging"] = logging;
    }
    if (typeof timeout !== "undefined") {
      payload["timeout"] = timeout;
    }
    if (typeof installCommand !== "undefined") {
      payload["installCommand"] = installCommand;
    }
    if (typeof buildCommand !== "undefined") {
      payload["buildCommand"] = buildCommand;
    }
    if (typeof outputDirectory !== "undefined") {
      payload["outputDirectory"] = outputDirectory;
    }
    if (typeof buildRuntime !== "undefined") {
      payload["buildRuntime"] = buildRuntime;
    }
    if (typeof adapter !== "undefined") {
      payload["adapter"] = adapter;
    }
    if (typeof fallbackFile !== "undefined") {
      payload["fallbackFile"] = fallbackFile;
    }
    if (typeof installationId !== "undefined") {
      payload["installationId"] = installationId;
    }
    if (typeof providerRepositoryId !== "undefined") {
      payload["providerRepositoryId"] = providerRepositoryId;
    }
    if (typeof providerBranch !== "undefined") {
      payload["providerBranch"] = providerBranch;
    }
    if (typeof providerSilentMode !== "undefined") {
      payload["providerSilentMode"] = providerSilentMode;
    }
    if (typeof providerRootDirectory !== "undefined") {
      payload["providerRootDirectory"] = providerRootDirectory;
    }
    if (typeof specification !== "undefined") {
      payload["specification"] = specification;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst
      };
    }
    const siteId = params.siteId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    const apiPath = "/sites/{siteId}".replace("{siteId}", siteId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  updateSiteDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const siteId = params.siteId;
    const deploymentId = params.deploymentId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/sites/{siteId}/deployment".replace("{siteId}", siteId);
    const payload = {};
    if (typeof deploymentId !== "undefined") {
      payload["deploymentId"] = deploymentId;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listDeployments(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        queries: rest[0],
        search: rest[1]
      };
    }
    const siteId = params.siteId;
    const queries = params.queries;
    const search = params.search;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    const apiPath = "/sites/{siteId}/deployments".replace("{siteId}", siteId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createDeployment(paramsOrFirst, ...rest) {
    let params;
    let onProgress;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
      onProgress = paramsOrFirst == null ? void 0 : paramsOrFirst.onProgress;
    } else {
      params = {
        siteId: paramsOrFirst,
        code: rest[0],
        activate: rest[1],
        installCommand: rest[2],
        buildCommand: rest[3],
        outputDirectory: rest[4]
      };
      onProgress = rest[5];
    }
    const siteId = params.siteId;
    const code = params.code;
    const activate = params.activate;
    const installCommand = params.installCommand;
    const buildCommand = params.buildCommand;
    const outputDirectory = params.outputDirectory;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    if (typeof activate === "undefined") {
      throw new AppwriteException('Missing required parameter: "activate"');
    }
    const apiPath = "/sites/{siteId}/deployments".replace("{siteId}", siteId);
    const payload = {};
    if (typeof installCommand !== "undefined") {
      payload["installCommand"] = installCommand;
    }
    if (typeof buildCommand !== "undefined") {
      payload["buildCommand"] = buildCommand;
    }
    if (typeof outputDirectory !== "undefined") {
      payload["outputDirectory"] = outputDirectory;
    }
    if (typeof code !== "undefined") {
      payload["code"] = code;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "multipart/form-data"
    };
    return this.client.chunkedUpload(
      "post",
      uri,
      apiHeaders,
      payload,
      onProgress
    );
  }
  createDuplicateDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const siteId = params.siteId;
    const deploymentId = params.deploymentId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/sites/{siteId}/deployments/duplicate".replace("{siteId}", siteId);
    const payload = {};
    if (typeof deploymentId !== "undefined") {
      payload["deploymentId"] = deploymentId;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createTemplateDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        repository: rest[0],
        owner: rest[1],
        rootDirectory: rest[2],
        version: rest[3],
        activate: rest[4]
      };
    }
    const siteId = params.siteId;
    const repository = params.repository;
    const owner = params.owner;
    const rootDirectory = params.rootDirectory;
    const version = params.version;
    const activate = params.activate;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof repository === "undefined") {
      throw new AppwriteException('Missing required parameter: "repository"');
    }
    if (typeof owner === "undefined") {
      throw new AppwriteException('Missing required parameter: "owner"');
    }
    if (typeof rootDirectory === "undefined") {
      throw new AppwriteException('Missing required parameter: "rootDirectory"');
    }
    if (typeof version === "undefined") {
      throw new AppwriteException('Missing required parameter: "version"');
    }
    const apiPath = "/sites/{siteId}/deployments/template".replace("{siteId}", siteId);
    const payload = {};
    if (typeof repository !== "undefined") {
      payload["repository"] = repository;
    }
    if (typeof owner !== "undefined") {
      payload["owner"] = owner;
    }
    if (typeof rootDirectory !== "undefined") {
      payload["rootDirectory"] = rootDirectory;
    }
    if (typeof version !== "undefined") {
      payload["version"] = version;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createVcsDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        type: rest[0],
        reference: rest[1],
        activate: rest[2]
      };
    }
    const siteId = params.siteId;
    const type = params.type;
    const reference = params.reference;
    const activate = params.activate;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    if (typeof reference === "undefined") {
      throw new AppwriteException('Missing required parameter: "reference"');
    }
    const apiPath = "/sites/{siteId}/deployments/vcs".replace("{siteId}", siteId);
    const payload = {};
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    if (typeof reference !== "undefined") {
      payload["reference"] = reference;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const siteId = params.siteId;
    const deploymentId = params.deploymentId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/sites/{siteId}/deployments/{deploymentId}".replace("{siteId}", siteId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const siteId = params.siteId;
    const deploymentId = params.deploymentId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/sites/{siteId}/deployments/{deploymentId}".replace("{siteId}", siteId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  getDeploymentDownload(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        deploymentId: rest[0],
        type: rest[1]
      };
    }
    const siteId = params.siteId;
    const deploymentId = params.deploymentId;
    const type = params.type;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/sites/{siteId}/deployments/{deploymentId}/download".replace("{siteId}", siteId).replace("{deploymentId}", deploymentId);
    const payload = {};
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  updateDeploymentStatus(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const siteId = params.siteId;
    const deploymentId = params.deploymentId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/sites/{siteId}/deployments/{deploymentId}/status".replace("{siteId}", siteId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listLogs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const siteId = params.siteId;
    const queries = params.queries;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    const apiPath = "/sites/{siteId}/logs".replace("{siteId}", siteId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getLog(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        logId: rest[0]
      };
    }
    const siteId = params.siteId;
    const logId = params.logId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof logId === "undefined") {
      throw new AppwriteException('Missing required parameter: "logId"');
    }
    const apiPath = "/sites/{siteId}/logs/{logId}".replace("{siteId}", siteId).replace("{logId}", logId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteLog(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        logId: rest[0]
      };
    }
    const siteId = params.siteId;
    const logId = params.logId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof logId === "undefined") {
      throw new AppwriteException('Missing required parameter: "logId"');
    }
    const apiPath = "/sites/{siteId}/logs/{logId}".replace("{siteId}", siteId).replace("{logId}", logId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listVariables(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst
      };
    }
    const siteId = params.siteId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    const apiPath = "/sites/{siteId}/variables".replace("{siteId}", siteId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        key: rest[0],
        value: rest[1],
        secret: rest[2]
      };
    }
    const siteId = params.siteId;
    const key = params.key;
    const value = params.value;
    const secret = params.secret;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof value === "undefined") {
      throw new AppwriteException('Missing required parameter: "value"');
    }
    const apiPath = "/sites/{siteId}/variables".replace("{siteId}", siteId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        variableId: rest[0]
      };
    }
    const siteId = params.siteId;
    const variableId = params.variableId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    const apiPath = "/sites/{siteId}/variables/{variableId}".replace("{siteId}", siteId).replace("{variableId}", variableId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        variableId: rest[0],
        key: rest[1],
        value: rest[2],
        secret: rest[3]
      };
    }
    const siteId = params.siteId;
    const variableId = params.variableId;
    const key = params.key;
    const value = params.value;
    const secret = params.secret;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/sites/{siteId}/variables/{variableId}".replace("{siteId}", siteId).replace("{variableId}", variableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        siteId: paramsOrFirst,
        variableId: rest[0]
      };
    }
    const siteId = params.siteId;
    const variableId = params.variableId;
    if (typeof siteId === "undefined") {
      throw new AppwriteException('Missing required parameter: "siteId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    const apiPath = "/sites/{siteId}/variables/{variableId}".replace("{siteId}", siteId).replace("{variableId}", variableId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/storage.mjs
var Storage = class {
  constructor(client) {
    this.client = client;
  }
  listBuckets(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/storage/buckets";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createBucket(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        name: rest[0],
        permissions: rest[1],
        fileSecurity: rest[2],
        enabled: rest[3],
        maximumFileSize: rest[4],
        allowedFileExtensions: rest[5],
        compression: rest[6],
        encryption: rest[7],
        antivirus: rest[8]
      };
    }
    const bucketId = params.bucketId;
    const name = params.name;
    const permissions = params.permissions;
    const fileSecurity = params.fileSecurity;
    const enabled = params.enabled;
    const maximumFileSize = params.maximumFileSize;
    const allowedFileExtensions = params.allowedFileExtensions;
    const compression = params.compression;
    const encryption = params.encryption;
    const antivirus = params.antivirus;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/storage/buckets";
    const payload = {};
    if (typeof bucketId !== "undefined") {
      payload["bucketId"] = bucketId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    if (typeof fileSecurity !== "undefined") {
      payload["fileSecurity"] = fileSecurity;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof maximumFileSize !== "undefined") {
      payload["maximumFileSize"] = maximumFileSize;
    }
    if (typeof allowedFileExtensions !== "undefined") {
      payload["allowedFileExtensions"] = allowedFileExtensions;
    }
    if (typeof compression !== "undefined") {
      payload["compression"] = compression;
    }
    if (typeof encryption !== "undefined") {
      payload["encryption"] = encryption;
    }
    if (typeof antivirus !== "undefined") {
      payload["antivirus"] = antivirus;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getBucket(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst
      };
    }
    const bucketId = params.bucketId;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateBucket(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        name: rest[0],
        permissions: rest[1],
        fileSecurity: rest[2],
        enabled: rest[3],
        maximumFileSize: rest[4],
        allowedFileExtensions: rest[5],
        compression: rest[6],
        encryption: rest[7],
        antivirus: rest[8]
      };
    }
    const bucketId = params.bucketId;
    const name = params.name;
    const permissions = params.permissions;
    const fileSecurity = params.fileSecurity;
    const enabled = params.enabled;
    const maximumFileSize = params.maximumFileSize;
    const allowedFileExtensions = params.allowedFileExtensions;
    const compression = params.compression;
    const encryption = params.encryption;
    const antivirus = params.antivirus;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    if (typeof fileSecurity !== "undefined") {
      payload["fileSecurity"] = fileSecurity;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof maximumFileSize !== "undefined") {
      payload["maximumFileSize"] = maximumFileSize;
    }
    if (typeof allowedFileExtensions !== "undefined") {
      payload["allowedFileExtensions"] = allowedFileExtensions;
    }
    if (typeof compression !== "undefined") {
      payload["compression"] = compression;
    }
    if (typeof encryption !== "undefined") {
      payload["encryption"] = encryption;
    }
    if (typeof antivirus !== "undefined") {
      payload["antivirus"] = antivirus;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteBucket(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst
      };
    }
    const bucketId = params.bucketId;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listFiles(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        queries: rest[0],
        search: rest[1]
      };
    }
    const bucketId = params.bucketId;
    const queries = params.queries;
    const search = params.search;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    const apiPath = "/storage/buckets/{bucketId}/files".replace("{bucketId}", bucketId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createFile(paramsOrFirst, ...rest) {
    let params;
    let onProgress;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
      onProgress = paramsOrFirst == null ? void 0 : paramsOrFirst.onProgress;
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0],
        file: rest[1],
        permissions: rest[2]
      };
      onProgress = rest[3];
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    const file = params.file;
    const permissions = params.permissions;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    if (typeof file === "undefined") {
      throw new AppwriteException('Missing required parameter: "file"');
    }
    const apiPath = "/storage/buckets/{bucketId}/files".replace("{bucketId}", bucketId);
    const payload = {};
    if (typeof fileId !== "undefined") {
      payload["fileId"] = fileId;
    }
    if (typeof file !== "undefined") {
      payload["file"] = file;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "multipart/form-data"
    };
    return this.client.chunkedUpload(
      "post",
      uri,
      apiHeaders,
      payload,
      onProgress
    );
  }
  getFile(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0]
      };
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateFile(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0],
        name: rest[1],
        permissions: rest[2]
      };
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    const name = params.name;
    const permissions = params.permissions;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteFile(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0]
      };
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  getFileDownload(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0],
        token: rest[1]
      };
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    const token = params.token;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/download".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    const payload = {};
    if (typeof token !== "undefined") {
      payload["token"] = token;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  getFilePreview(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0],
        width: rest[1],
        height: rest[2],
        gravity: rest[3],
        quality: rest[4],
        borderWidth: rest[5],
        borderColor: rest[6],
        borderRadius: rest[7],
        opacity: rest[8],
        rotation: rest[9],
        background: rest[10],
        output: rest[11],
        token: rest[12]
      };
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    const width = params.width;
    const height = params.height;
    const gravity = params.gravity;
    const quality = params.quality;
    const borderWidth = params.borderWidth;
    const borderColor = params.borderColor;
    const borderRadius = params.borderRadius;
    const opacity = params.opacity;
    const rotation = params.rotation;
    const background = params.background;
    const output = params.output;
    const token = params.token;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/preview".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    const payload = {};
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof gravity !== "undefined") {
      payload["gravity"] = gravity;
    }
    if (typeof quality !== "undefined") {
      payload["quality"] = quality;
    }
    if (typeof borderWidth !== "undefined") {
      payload["borderWidth"] = borderWidth;
    }
    if (typeof borderColor !== "undefined") {
      payload["borderColor"] = borderColor;
    }
    if (typeof borderRadius !== "undefined") {
      payload["borderRadius"] = borderRadius;
    }
    if (typeof opacity !== "undefined") {
      payload["opacity"] = opacity;
    }
    if (typeof rotation !== "undefined") {
      payload["rotation"] = rotation;
    }
    if (typeof background !== "undefined") {
      payload["background"] = background;
    }
    if (typeof output !== "undefined") {
      payload["output"] = output;
    }
    if (typeof token !== "undefined") {
      payload["token"] = token;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  getFileView(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0],
        token: rest[1]
      };
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    const token = params.token;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/view".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    const payload = {};
    if (typeof token !== "undefined") {
      payload["token"] = token;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
};

// node_modules/node-appwrite/dist/services/tables-db.mjs
var TablesDB = class {
  constructor(client) {
    this.client = client;
  }
  list(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/tablesdb";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const name = params.name;
    const enabled = params.enabled;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/tablesdb";
    const payload = {};
    if (typeof databaseId !== "undefined") {
      payload["databaseId"] = databaseId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  get(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst
      };
    }
    const databaseId = params.databaseId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    const apiPath = "/tablesdb/{databaseId}".replace("{databaseId}", databaseId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  update(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        name: rest[0],
        enabled: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const name = params.name;
    const enabled = params.enabled;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/tablesdb/{databaseId}".replace("{databaseId}", databaseId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst
      };
    }
    const databaseId = params.databaseId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    const apiPath = "/tablesdb/{databaseId}".replace("{databaseId}", databaseId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listTables(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        queries: rest[0],
        search: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const queries = params.queries;
    const search = params.search;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables".replace("{databaseId}", databaseId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createTable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        name: rest[1],
        permissions: rest[2],
        rowSecurity: rest[3],
        enabled: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const name = params.name;
    const permissions = params.permissions;
    const rowSecurity = params.rowSecurity;
    const enabled = params.enabled;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables".replace("{databaseId}", databaseId);
    const payload = {};
    if (typeof tableId !== "undefined") {
      payload["tableId"] = tableId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    if (typeof rowSecurity !== "undefined") {
      payload["rowSecurity"] = rowSecurity;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getTable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateTable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        name: rest[1],
        permissions: rest[2],
        rowSecurity: rest[3],
        enabled: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const name = params.name;
    const permissions = params.permissions;
    const rowSecurity = params.rowSecurity;
    const enabled = params.enabled;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    if (typeof rowSecurity !== "undefined") {
      payload["rowSecurity"] = rowSecurity;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteTable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listColumns(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        queries: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createBooleanColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/boolean".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateBooleanColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/boolean/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createDatetimeColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/datetime".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateDatetimeColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/datetime/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createEmailColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/email".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEmailColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/email/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createEnumColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        elements: rest[2],
        required: rest[3],
        xdefault: rest[4],
        array: rest[5]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const elements = params.elements;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof elements === "undefined") {
      throw new AppwriteException('Missing required parameter: "elements"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/enum".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof elements !== "undefined") {
      payload["elements"] = elements;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEnumColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        elements: rest[2],
        required: rest[3],
        xdefault: rest[4],
        newKey: rest[5]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const elements = params.elements;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof elements === "undefined") {
      throw new AppwriteException('Missing required parameter: "elements"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/enum/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof elements !== "undefined") {
      payload["elements"] = elements;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createFloatColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        min: rest[3],
        max: rest[4],
        xdefault: rest[5],
        array: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const min = params.min;
    const max = params.max;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/float".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateFloatColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        min: rest[4],
        max: rest[5],
        newKey: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const min = params.min;
    const max = params.max;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/float/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createIntegerColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        min: rest[3],
        max: rest[4],
        xdefault: rest[5],
        array: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const min = params.min;
    const max = params.max;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/integer".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateIntegerColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        min: rest[4],
        max: rest[5],
        newKey: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const min = params.min;
    const max = params.max;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/integer/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createIpColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/ip".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateIpColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/ip/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createLineColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/line".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateLineColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/line/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createPointColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/point".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePointColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/point/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createPolygonColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/polygon".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePolygonColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/polygon/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createRelationshipColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        relatedTableId: rest[1],
        type: rest[2],
        twoWay: rest[3],
        key: rest[4],
        twoWayKey: rest[5],
        onDelete: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const relatedTableId = params.relatedTableId;
    const type = params.type;
    const twoWay = params.twoWay;
    const key = params.key;
    const twoWayKey = params.twoWayKey;
    const onDelete = params.onDelete;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof relatedTableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "relatedTableId"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/relationship".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof relatedTableId !== "undefined") {
      payload["relatedTableId"] = relatedTableId;
    }
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    if (typeof twoWay !== "undefined") {
      payload["twoWay"] = twoWay;
    }
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof twoWayKey !== "undefined") {
      payload["twoWayKey"] = twoWayKey;
    }
    if (typeof onDelete !== "undefined") {
      payload["onDelete"] = onDelete;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createStringColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        size: rest[2],
        required: rest[3],
        xdefault: rest[4],
        array: rest[5],
        encrypt: rest[6]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const size = params.size;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    const encrypt = params.encrypt;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof size === "undefined") {
      throw new AppwriteException('Missing required parameter: "size"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/string".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof size !== "undefined") {
      payload["size"] = size;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    if (typeof encrypt !== "undefined") {
      payload["encrypt"] = encrypt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateStringColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        size: rest[4],
        newKey: rest[5]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const size = params.size;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/string/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof size !== "undefined") {
      payload["size"] = size;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createUrlColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        array: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const array = params.array;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/url".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof array !== "undefined") {
      payload["array"] = array;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateUrlColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        required: rest[2],
        xdefault: rest[3],
        newKey: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const required = params.required;
    const xdefault = params.xdefault;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof required === "undefined") {
      throw new AppwriteException('Missing required parameter: "required"');
    }
    if (typeof xdefault === "undefined") {
      throw new AppwriteException('Missing required parameter: "xdefault"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/url/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof required !== "undefined") {
      payload["required"] = required;
    }
    if (typeof xdefault !== "undefined") {
      payload["default"] = xdefault;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  getColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  updateRelationshipColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        onDelete: rest[2],
        newKey: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const onDelete = params.onDelete;
    const newKey = params.newKey;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/{key}/relationship".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    if (typeof onDelete !== "undefined") {
      payload["onDelete"] = onDelete;
    }
    if (typeof newKey !== "undefined") {
      payload["newKey"] = newKey;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listIndexes(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        queries: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/indexes".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createIndex(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1],
        type: rest[2],
        columns: rest[3],
        orders: rest[4],
        lengths: rest[5]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    const type = params.type;
    const columns = params.columns;
    const orders = params.orders;
    const lengths = params.lengths;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    if (typeof columns === "undefined") {
      throw new AppwriteException('Missing required parameter: "columns"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/indexes".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    if (typeof columns !== "undefined") {
      payload["columns"] = columns;
    }
    if (typeof orders !== "undefined") {
      payload["orders"] = orders;
    }
    if (typeof lengths !== "undefined") {
      payload["lengths"] = lengths;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getIndex(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteIndex(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        key: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const key = params.key;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listRows(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        queries: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createRow(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rowId: rest[1],
        data: rest[2],
        permissions: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rowId = params.rowId;
    const data = params.data;
    const permissions = params.permissions;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rowId === "undefined") {
      throw new AppwriteException('Missing required parameter: "rowId"');
    }
    if (typeof data === "undefined") {
      throw new AppwriteException('Missing required parameter: "data"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof rowId !== "undefined") {
      payload["rowId"] = rowId;
    }
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createRows(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rows: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rows = params.rows;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rows === "undefined") {
      throw new AppwriteException('Missing required parameter: "rows"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof rows !== "undefined") {
      payload["rows"] = rows;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  upsertRows(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rows: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rows = params.rows;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rows === "undefined") {
      throw new AppwriteException('Missing required parameter: "rows"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof rows !== "undefined") {
      payload["rows"] = rows;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateRows(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        data: rest[1],
        queries: rest[2]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const data = params.data;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteRows(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        queries: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  getRow(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rowId: rest[1],
        queries: rest[2]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rowId = params.rowId;
    const queries = params.queries;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rowId === "undefined") {
      throw new AppwriteException('Missing required parameter: "rowId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  upsertRow(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rowId: rest[1],
        data: rest[2],
        permissions: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rowId = params.rowId;
    const data = params.data;
    const permissions = params.permissions;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rowId === "undefined") {
      throw new AppwriteException('Missing required parameter: "rowId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId);
    const payload = {};
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateRow(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rowId: rest[1],
        data: rest[2],
        permissions: rest[3]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rowId = params.rowId;
    const data = params.data;
    const permissions = params.permissions;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rowId === "undefined") {
      throw new AppwriteException('Missing required parameter: "rowId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId);
    const payload = {};
    if (typeof data !== "undefined") {
      payload["data"] = data;
    }
    if (typeof permissions !== "undefined") {
      payload["permissions"] = permissions;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteRow(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rowId: rest[1]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rowId = params.rowId;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rowId === "undefined") {
      throw new AppwriteException('Missing required parameter: "rowId"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  decrementRowColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rowId: rest[1],
        column: rest[2],
        value: rest[3],
        min: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rowId = params.rowId;
    const column = params.column;
    const value = params.value;
    const min = params.min;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rowId === "undefined") {
      throw new AppwriteException('Missing required parameter: "rowId"');
    }
    if (typeof column === "undefined") {
      throw new AppwriteException('Missing required parameter: "column"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/decrement".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId).replace("{column}", column);
    const payload = {};
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof min !== "undefined") {
      payload["min"] = min;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  incrementRowColumn(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        databaseId: paramsOrFirst,
        tableId: rest[0],
        rowId: rest[1],
        column: rest[2],
        value: rest[3],
        max: rest[4]
      };
    }
    const databaseId = params.databaseId;
    const tableId = params.tableId;
    const rowId = params.rowId;
    const column = params.column;
    const value = params.value;
    const max = params.max;
    if (typeof databaseId === "undefined") {
      throw new AppwriteException('Missing required parameter: "databaseId"');
    }
    if (typeof tableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tableId"');
    }
    if (typeof rowId === "undefined") {
      throw new AppwriteException('Missing required parameter: "rowId"');
    }
    if (typeof column === "undefined") {
      throw new AppwriteException('Missing required parameter: "column"');
    }
    const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/increment".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId).replace("{column}", column);
    const payload = {};
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof max !== "undefined") {
      payload["max"] = max;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/teams.mjs
var Teams = class {
  constructor(client) {
    this.client = client;
  }
  list(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/teams";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        name: rest[0],
        roles: rest[1]
      };
    }
    const teamId = params.teamId;
    const name = params.name;
    const roles = params.roles;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/teams";
    const payload = {};
    if (typeof teamId !== "undefined") {
      payload["teamId"] = teamId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof roles !== "undefined") {
      payload["roles"] = roles;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  get(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst
      };
    }
    const teamId = params.teamId;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateName(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        name: rest[0]
      };
    }
    const teamId = params.teamId;
    const name = params.name;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst
      };
    }
    const teamId = params.teamId;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listMemberships(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        queries: rest[0],
        search: rest[1]
      };
    }
    const teamId = params.teamId;
    const queries = params.queries;
    const search = params.search;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    const apiPath = "/teams/{teamId}/memberships".replace("{teamId}", teamId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createMembership(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        roles: rest[0],
        email: rest[1],
        userId: rest[2],
        phone: rest[3],
        url: rest[4],
        name: rest[5]
      };
    }
    const teamId = params.teamId;
    const roles = params.roles;
    const email = params.email;
    const userId = params.userId;
    const phone = params.phone;
    const url = params.url;
    const name = params.name;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    if (typeof roles === "undefined") {
      throw new AppwriteException('Missing required parameter: "roles"');
    }
    const apiPath = "/teams/{teamId}/memberships".replace("{teamId}", teamId);
    const payload = {};
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof phone !== "undefined") {
      payload["phone"] = phone;
    }
    if (typeof roles !== "undefined") {
      payload["roles"] = roles;
    }
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getMembership(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        membershipId: rest[0]
      };
    }
    const teamId = params.teamId;
    const membershipId = params.membershipId;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    if (typeof membershipId === "undefined") {
      throw new AppwriteException('Missing required parameter: "membershipId"');
    }
    const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMembership(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        membershipId: rest[0],
        roles: rest[1]
      };
    }
    const teamId = params.teamId;
    const membershipId = params.membershipId;
    const roles = params.roles;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    if (typeof membershipId === "undefined") {
      throw new AppwriteException('Missing required parameter: "membershipId"');
    }
    if (typeof roles === "undefined") {
      throw new AppwriteException('Missing required parameter: "roles"');
    }
    const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
    const payload = {};
    if (typeof roles !== "undefined") {
      payload["roles"] = roles;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteMembership(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        membershipId: rest[0]
      };
    }
    const teamId = params.teamId;
    const membershipId = params.membershipId;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    if (typeof membershipId === "undefined") {
      throw new AppwriteException('Missing required parameter: "membershipId"');
    }
    const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMembershipStatus(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        membershipId: rest[0],
        userId: rest[1],
        secret: rest[2]
      };
    }
    const teamId = params.teamId;
    const membershipId = params.membershipId;
    const userId = params.userId;
    const secret = params.secret;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    if (typeof membershipId === "undefined") {
      throw new AppwriteException('Missing required parameter: "membershipId"');
    }
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/teams/{teamId}/memberships/{membershipId}/status".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  getPrefs(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst
      };
    }
    const teamId = params.teamId;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    const apiPath = "/teams/{teamId}/prefs".replace("{teamId}", teamId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePrefs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        teamId: paramsOrFirst,
        prefs: rest[0]
      };
    }
    const teamId = params.teamId;
    const prefs = params.prefs;
    if (typeof teamId === "undefined") {
      throw new AppwriteException('Missing required parameter: "teamId"');
    }
    if (typeof prefs === "undefined") {
      throw new AppwriteException('Missing required parameter: "prefs"');
    }
    const apiPath = "/teams/{teamId}/prefs".replace("{teamId}", teamId);
    const payload = {};
    if (typeof prefs !== "undefined") {
      payload["prefs"] = prefs;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/tokens.mjs
var Tokens = class {
  constructor(client) {
    this.client = client;
  }
  list(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0],
        queries: rest[1]
      };
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    const queries = params.queries;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    const apiPath = "/tokens/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createFileToken(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        bucketId: paramsOrFirst,
        fileId: rest[0],
        expire: rest[1]
      };
    }
    const bucketId = params.bucketId;
    const fileId = params.fileId;
    const expire = params.expire;
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    const apiPath = "/tokens/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    const payload = {};
    if (typeof expire !== "undefined") {
      payload["expire"] = expire;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  get(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        tokenId: paramsOrFirst
      };
    }
    const tokenId = params.tokenId;
    if (typeof tokenId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tokenId"');
    }
    const apiPath = "/tokens/{tokenId}".replace("{tokenId}", tokenId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  update(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        tokenId: paramsOrFirst,
        expire: rest[0]
      };
    }
    const tokenId = params.tokenId;
    const expire = params.expire;
    if (typeof tokenId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tokenId"');
    }
    const apiPath = "/tokens/{tokenId}".replace("{tokenId}", tokenId);
    const payload = {};
    if (typeof expire !== "undefined") {
      payload["expire"] = expire;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        tokenId: paramsOrFirst
      };
    }
    const tokenId = params.tokenId;
    if (typeof tokenId === "undefined") {
      throw new AppwriteException('Missing required parameter: "tokenId"');
    }
    const apiPath = "/tokens/{tokenId}".replace("{tokenId}", tokenId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/services/users.mjs
var Users = class {
  constructor(client) {
    this.client = client;
  }
  list(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/users";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        phone: rest[1],
        password: rest[2],
        name: rest[3]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const phone = params.phone;
    const password = params.password;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof phone !== "undefined") {
      payload["phone"] = phone;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createArgon2User(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        name: rest[2]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/users/argon2";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createBcryptUser(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        name: rest[2]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/users/bcrypt";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  listIdentities(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const apiPath = "/users/identities";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteIdentity(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        identityId: paramsOrFirst
      };
    }
    const identityId = params.identityId;
    if (typeof identityId === "undefined") {
      throw new AppwriteException('Missing required parameter: "identityId"');
    }
    const apiPath = "/users/identities/{identityId}".replace("{identityId}", identityId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  createMD5User(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        name: rest[2]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/users/md5";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createPHPassUser(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        name: rest[2]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/users/phpass";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createScryptUser(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        passwordSalt: rest[2],
        passwordCpu: rest[3],
        passwordMemory: rest[4],
        passwordParallel: rest[5],
        passwordLength: rest[6],
        name: rest[7]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const passwordSalt = params.passwordSalt;
    const passwordCpu = params.passwordCpu;
    const passwordMemory = params.passwordMemory;
    const passwordParallel = params.passwordParallel;
    const passwordLength = params.passwordLength;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    if (typeof passwordSalt === "undefined") {
      throw new AppwriteException('Missing required parameter: "passwordSalt"');
    }
    if (typeof passwordCpu === "undefined") {
      throw new AppwriteException('Missing required parameter: "passwordCpu"');
    }
    if (typeof passwordMemory === "undefined") {
      throw new AppwriteException('Missing required parameter: "passwordMemory"');
    }
    if (typeof passwordParallel === "undefined") {
      throw new AppwriteException('Missing required parameter: "passwordParallel"');
    }
    if (typeof passwordLength === "undefined") {
      throw new AppwriteException('Missing required parameter: "passwordLength"');
    }
    const apiPath = "/users/scrypt";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof passwordSalt !== "undefined") {
      payload["passwordSalt"] = passwordSalt;
    }
    if (typeof passwordCpu !== "undefined") {
      payload["passwordCpu"] = passwordCpu;
    }
    if (typeof passwordMemory !== "undefined") {
      payload["passwordMemory"] = passwordMemory;
    }
    if (typeof passwordParallel !== "undefined") {
      payload["passwordParallel"] = passwordParallel;
    }
    if (typeof passwordLength !== "undefined") {
      payload["passwordLength"] = passwordLength;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createScryptModifiedUser(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        passwordSalt: rest[2],
        passwordSaltSeparator: rest[3],
        passwordSignerKey: rest[4],
        name: rest[5]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const passwordSalt = params.passwordSalt;
    const passwordSaltSeparator = params.passwordSaltSeparator;
    const passwordSignerKey = params.passwordSignerKey;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    if (typeof passwordSalt === "undefined") {
      throw new AppwriteException('Missing required parameter: "passwordSalt"');
    }
    if (typeof passwordSaltSeparator === "undefined") {
      throw new AppwriteException('Missing required parameter: "passwordSaltSeparator"');
    }
    if (typeof passwordSignerKey === "undefined") {
      throw new AppwriteException('Missing required parameter: "passwordSignerKey"');
    }
    const apiPath = "/users/scrypt-modified";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof passwordSalt !== "undefined") {
      payload["passwordSalt"] = passwordSalt;
    }
    if (typeof passwordSaltSeparator !== "undefined") {
      payload["passwordSaltSeparator"] = passwordSaltSeparator;
    }
    if (typeof passwordSignerKey !== "undefined") {
      payload["passwordSignerKey"] = passwordSignerKey;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createSHAUser(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        passwordVersion: rest[2],
        name: rest[3]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const passwordVersion = params.passwordVersion;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/users/sha";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof passwordVersion !== "undefined") {
      payload["passwordVersion"] = passwordVersion;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  get(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEmail(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0]
      };
    }
    const userId = params.userId;
    const email = params.email;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new AppwriteException('Missing required parameter: "email"');
    }
    const apiPath = "/users/{userId}/email".replace("{userId}", userId);
    const payload = {};
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createJWT(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        sessionId: rest[0],
        duration: rest[1]
      };
    }
    const userId = params.userId;
    const sessionId = params.sessionId;
    const duration = params.duration;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/jwts".replace("{userId}", userId);
    const payload = {};
    if (typeof sessionId !== "undefined") {
      payload["sessionId"] = sessionId;
    }
    if (typeof duration !== "undefined") {
      payload["duration"] = duration;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateLabels(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        labels: rest[0]
      };
    }
    const userId = params.userId;
    const labels = params.labels;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof labels === "undefined") {
      throw new AppwriteException('Missing required parameter: "labels"');
    }
    const apiPath = "/users/{userId}/labels".replace("{userId}", userId);
    const payload = {};
    if (typeof labels !== "undefined") {
      payload["labels"] = labels;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  listLogs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const userId = params.userId;
    const queries = params.queries;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/logs".replace("{userId}", userId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  listMemberships(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        queries: rest[0],
        search: rest[1]
      };
    }
    const userId = params.userId;
    const queries = params.queries;
    const search = params.search;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/memberships".replace("{userId}", userId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMfa(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        mfa: rest[0]
      };
    }
    const userId = params.userId;
    const mfa = params.mfa;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof mfa === "undefined") {
      throw new AppwriteException('Missing required parameter: "mfa"');
    }
    const apiPath = "/users/{userId}/mfa".replace("{userId}", userId);
    const payload = {};
    if (typeof mfa !== "undefined") {
      payload["mfa"] = mfa;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMFA(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        mfa: rest[0]
      };
    }
    const userId = params.userId;
    const mfa = params.mfa;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof mfa === "undefined") {
      throw new AppwriteException('Missing required parameter: "mfa"');
    }
    const apiPath = "/users/{userId}/mfa".replace("{userId}", userId);
    const payload = {};
    if (typeof mfa !== "undefined") {
      payload["mfa"] = mfa;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteMfaAuthenticator(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        type: rest[0]
      };
    }
    const userId = params.userId;
    const type = params.type;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/users/{userId}/mfa/authenticators/{type}".replace("{userId}", userId).replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteMFAAuthenticator(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        type: rest[0]
      };
    }
    const userId = params.userId;
    const type = params.type;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/users/{userId}/mfa/authenticators/{type}".replace("{userId}", userId).replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listMfaFactors(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/mfa/factors".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  listMFAFactors(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/mfa/factors".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getMfaRecoveryCodes(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getMFARecoveryCodes(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMfaRecoveryCodes(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMFARecoveryCodes(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  createMfaRecoveryCodes(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createMFARecoveryCodes(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updateName(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        name: rest[0]
      };
    }
    const userId = params.userId;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/users/{userId}/name".replace("{userId}", userId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePassword(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        password: rest[0]
      };
    }
    const userId = params.userId;
    const password = params.password;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof password === "undefined") {
      throw new AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/users/{userId}/password".replace("{userId}", userId);
    const payload = {};
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePhone(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        number: rest[0]
      };
    }
    const userId = params.userId;
    const number = params.number;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof number === "undefined") {
      throw new AppwriteException('Missing required parameter: "number"');
    }
    const apiPath = "/users/{userId}/phone".replace("{userId}", userId);
    const payload = {};
    if (typeof number !== "undefined") {
      payload["number"] = number;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  getPrefs(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/prefs".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePrefs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        prefs: rest[0]
      };
    }
    const userId = params.userId;
    const prefs = params.prefs;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof prefs === "undefined") {
      throw new AppwriteException('Missing required parameter: "prefs"');
    }
    const apiPath = "/users/{userId}/prefs".replace("{userId}", userId);
    const payload = {};
    if (typeof prefs !== "undefined") {
      payload["prefs"] = prefs;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listSessions(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createSession(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteSessions(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst
      };
    }
    const userId = params.userId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        sessionId: rest[0]
      };
    }
    const userId = params.userId;
    const sessionId = params.sessionId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof sessionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "sessionId"');
    }
    const apiPath = "/users/{userId}/sessions/{sessionId}".replace("{userId}", userId).replace("{sessionId}", sessionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  updateStatus(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        status: rest[0]
      };
    }
    const userId = params.userId;
    const status = params.status;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof status === "undefined") {
      throw new AppwriteException('Missing required parameter: "status"');
    }
    const apiPath = "/users/{userId}/status".replace("{userId}", userId);
    const payload = {};
    if (typeof status !== "undefined") {
      payload["status"] = status;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listTargets(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        queries: rest[0]
      };
    }
    const userId = params.userId;
    const queries = params.queries;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/targets".replace("{userId}", userId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createTarget(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        targetId: rest[0],
        providerType: rest[1],
        identifier: rest[2],
        providerId: rest[3],
        name: rest[4]
      };
    }
    const userId = params.userId;
    const targetId = params.targetId;
    const providerType = params.providerType;
    const identifier = params.identifier;
    const providerId = params.providerId;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof targetId === "undefined") {
      throw new AppwriteException('Missing required parameter: "targetId"');
    }
    if (typeof providerType === "undefined") {
      throw new AppwriteException('Missing required parameter: "providerType"');
    }
    if (typeof identifier === "undefined") {
      throw new AppwriteException('Missing required parameter: "identifier"');
    }
    const apiPath = "/users/{userId}/targets".replace("{userId}", userId);
    const payload = {};
    if (typeof targetId !== "undefined") {
      payload["targetId"] = targetId;
    }
    if (typeof providerType !== "undefined") {
      payload["providerType"] = providerType;
    }
    if (typeof identifier !== "undefined") {
      payload["identifier"] = identifier;
    }
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getTarget(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        targetId: rest[0]
      };
    }
    const userId = params.userId;
    const targetId = params.targetId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof targetId === "undefined") {
      throw new AppwriteException('Missing required parameter: "targetId"');
    }
    const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateTarget(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        targetId: rest[0],
        identifier: rest[1],
        providerId: rest[2],
        name: rest[3]
      };
    }
    const userId = params.userId;
    const targetId = params.targetId;
    const identifier = params.identifier;
    const providerId = params.providerId;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof targetId === "undefined") {
      throw new AppwriteException('Missing required parameter: "targetId"');
    }
    const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
    const payload = {};
    if (typeof identifier !== "undefined") {
      payload["identifier"] = identifier;
    }
    if (typeof providerId !== "undefined") {
      payload["providerId"] = providerId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteTarget(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        targetId: rest[0]
      };
    }
    const userId = params.userId;
    const targetId = params.targetId;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof targetId === "undefined") {
      throw new AppwriteException('Missing required parameter: "targetId"');
    }
    const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  createToken(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        length: rest[0],
        expire: rest[1]
      };
    }
    const userId = params.userId;
    const length = params.length;
    const expire = params.expire;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    const apiPath = "/users/{userId}/tokens".replace("{userId}", userId);
    const payload = {};
    if (typeof length !== "undefined") {
      payload["length"] = length;
    }
    if (typeof expire !== "undefined") {
      payload["expire"] = expire;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEmailVerification(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        emailVerification: rest[0]
      };
    }
    const userId = params.userId;
    const emailVerification = params.emailVerification;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof emailVerification === "undefined") {
      throw new AppwriteException('Missing required parameter: "emailVerification"');
    }
    const apiPath = "/users/{userId}/verification".replace("{userId}", userId);
    const payload = {};
    if (typeof emailVerification !== "undefined") {
      payload["emailVerification"] = emailVerification;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePhoneVerification(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        phoneVerification: rest[0]
      };
    }
    const userId = params.userId;
    const phoneVerification = params.phoneVerification;
    if (typeof userId === "undefined") {
      throw new AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof phoneVerification === "undefined") {
      throw new AppwriteException('Missing required parameter: "phoneVerification"');
    }
    const apiPath = "/users/{userId}/verification/phone".replace("{userId}", userId);
    const payload = {};
    if (typeof phoneVerification !== "undefined") {
      payload["phoneVerification"] = phoneVerification;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
};

// node_modules/node-appwrite/dist/permission.mjs
var Permission = class {
};
Permission.read = (role) => {
  return `read("${role}")`;
};
Permission.write = (role) => {
  return `write("${role}")`;
};
Permission.create = (role) => {
  return `create("${role}")`;
};
Permission.update = (role) => {
  return `update("${role}")`;
};
Permission.delete = (role) => {
  return `delete("${role}")`;
};

// node_modules/node-appwrite/dist/role.mjs
var Role = class {
  /**
   * Grants access to anyone.
   * 
   * This includes authenticated and unauthenticated users.
   * 
   * @returns {string}
   */
  static any() {
    return "any";
  }
  /**
   * Grants access to a specific user by user ID.
   * 
   * You can optionally pass verified or unverified for
   * `status` to target specific types of users.
   *
   * @param {string} id 
   * @param {string} status 
   * @returns {string}
   */
  static user(id, status = "") {
    if (status === "") {
      return `user:${id}`;
    }
    return `user:${id}/${status}`;
  }
  /**
   * Grants access to any authenticated or anonymous user.
   * 
   * You can optionally pass verified or unverified for
   * `status` to target specific types of users.
   * 
   * @param {string} status 
   * @returns {string}
   */
  static users(status = "") {
    if (status === "") {
      return "users";
    }
    return `users/${status}`;
  }
  /**
   * Grants access to any guest user without a session.
   * 
   * Authenticated users don't have access to this role.
   * 
   * @returns {string}
   */
  static guests() {
    return "guests";
  }
  /**
   * Grants access to a team by team ID.
   * 
   * You can optionally pass a role for `role` to target
   * team members with the specified role.
   * 
   * @param {string} id 
   * @param {string} role 
   * @returns {string}
   */
  static team(id, role = "") {
    if (role === "") {
      return `team:${id}`;
    }
    return `team:${id}/${role}`;
  }
  /**
   * Grants access to a specific member of a team.
   * 
   * When the member is removed from the team, they will
   * no longer have access.
   * 
   * @param {string} id 
   * @returns {string}
   */
  static member(id) {
    return `member:${id}`;
  }
  /**
   * Grants access to a user with the specified label.
   * 
   * @param {string} name 
   * @returns  {string}
   */
  static label(name) {
    return `label:${name}`;
  }
};

// node_modules/node-appwrite/dist/id.mjs
var __ID_static, _a, hexTimestamp_fn;
var ID = (_a = class {
  /**
   * Uses the provided ID as the ID for the resource.
   *
   * @param {string} id
   * @returns {string}
   */
  static custom(id) {
    return id;
  }
  /**
   * Have Appwrite generate a unique ID for you.
   * 
   * @param {number} padding. Default is 7.
   * @returns {string}
   */
  static unique(padding = 7) {
    var _a2;
    const baseId = __privateMethod(_a2 = _a, __ID_static, hexTimestamp_fn).call(_a2);
    let randomPadding = "";
    for (let i3 = 0; i3 < padding; i3++) {
      const randomHexDigit = Math.floor(Math.random() * 16).toString(16);
      randomPadding += randomHexDigit;
    }
    return baseId + randomPadding;
  }
}, __ID_static = new WeakSet(), hexTimestamp_fn = function() {
  const now = /* @__PURE__ */ new Date();
  const sec = Math.floor(now.getTime() / 1e3);
  const msec = now.getMilliseconds();
  const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, "0");
  return hexTimestamp;
}, __privateAdd(_a, __ID_static), _a);

// node_modules/node-appwrite/dist/enums/authenticator-type.mjs
var AuthenticatorType = ((AuthenticatorType2) => {
  AuthenticatorType2["Totp"] = "totp";
  return AuthenticatorType2;
})(AuthenticatorType || {});

// node_modules/node-appwrite/dist/enums/authentication-factor.mjs
var AuthenticationFactor = ((AuthenticationFactor2) => {
  AuthenticationFactor2["Email"] = "email";
  AuthenticationFactor2["Phone"] = "phone";
  AuthenticationFactor2["Totp"] = "totp";
  AuthenticationFactor2["Recoverycode"] = "recoverycode";
  return AuthenticationFactor2;
})(AuthenticationFactor || {});

// node_modules/node-appwrite/dist/enums/o-auth-provider.mjs
var OAuthProvider = ((OAuthProvider2) => {
  OAuthProvider2["Amazon"] = "amazon";
  OAuthProvider2["Apple"] = "apple";
  OAuthProvider2["Auth0"] = "auth0";
  OAuthProvider2["Authentik"] = "authentik";
  OAuthProvider2["Autodesk"] = "autodesk";
  OAuthProvider2["Bitbucket"] = "bitbucket";
  OAuthProvider2["Bitly"] = "bitly";
  OAuthProvider2["Box"] = "box";
  OAuthProvider2["Dailymotion"] = "dailymotion";
  OAuthProvider2["Discord"] = "discord";
  OAuthProvider2["Disqus"] = "disqus";
  OAuthProvider2["Dropbox"] = "dropbox";
  OAuthProvider2["Etsy"] = "etsy";
  OAuthProvider2["Facebook"] = "facebook";
  OAuthProvider2["Figma"] = "figma";
  OAuthProvider2["Github"] = "github";
  OAuthProvider2["Gitlab"] = "gitlab";
  OAuthProvider2["Google"] = "google";
  OAuthProvider2["Linkedin"] = "linkedin";
  OAuthProvider2["Microsoft"] = "microsoft";
  OAuthProvider2["Notion"] = "notion";
  OAuthProvider2["Oidc"] = "oidc";
  OAuthProvider2["Okta"] = "okta";
  OAuthProvider2["Paypal"] = "paypal";
  OAuthProvider2["PaypalSandbox"] = "paypalSandbox";
  OAuthProvider2["Podio"] = "podio";
  OAuthProvider2["Salesforce"] = "salesforce";
  OAuthProvider2["Slack"] = "slack";
  OAuthProvider2["Spotify"] = "spotify";
  OAuthProvider2["Stripe"] = "stripe";
  OAuthProvider2["Tradeshift"] = "tradeshift";
  OAuthProvider2["TradeshiftBox"] = "tradeshiftBox";
  OAuthProvider2["Twitch"] = "twitch";
  OAuthProvider2["Wordpress"] = "wordpress";
  OAuthProvider2["Yahoo"] = "yahoo";
  OAuthProvider2["Yammer"] = "yammer";
  OAuthProvider2["Yandex"] = "yandex";
  OAuthProvider2["Zoho"] = "zoho";
  OAuthProvider2["Zoom"] = "zoom";
  OAuthProvider2["Mock"] = "mock";
  return OAuthProvider2;
})(OAuthProvider || {});

// node_modules/node-appwrite/dist/enums/browser.mjs
var Browser = ((Browser2) => {
  Browser2["AvantBrowser"] = "aa";
  Browser2["AndroidWebViewBeta"] = "an";
  Browser2["GoogleChrome"] = "ch";
  Browser2["GoogleChromeIOS"] = "ci";
  Browser2["GoogleChromeMobile"] = "cm";
  Browser2["Chromium"] = "cr";
  Browser2["MozillaFirefox"] = "ff";
  Browser2["Safari"] = "sf";
  Browser2["MobileSafari"] = "mf";
  Browser2["MicrosoftEdge"] = "ps";
  Browser2["MicrosoftEdgeIOS"] = "oi";
  Browser2["OperaMini"] = "om";
  Browser2["Opera"] = "op";
  Browser2["OperaNext"] = "on";
  return Browser2;
})(Browser || {});

// node_modules/node-appwrite/dist/enums/credit-card.mjs
var CreditCard = ((CreditCard2) => {
  CreditCard2["AmericanExpress"] = "amex";
  CreditCard2["Argencard"] = "argencard";
  CreditCard2["Cabal"] = "cabal";
  CreditCard2["Cencosud"] = "cencosud";
  CreditCard2["DinersClub"] = "diners";
  CreditCard2["Discover"] = "discover";
  CreditCard2["Elo"] = "elo";
  CreditCard2["Hipercard"] = "hipercard";
  CreditCard2["JCB"] = "jcb";
  CreditCard2["Mastercard"] = "mastercard";
  CreditCard2["Naranja"] = "naranja";
  CreditCard2["TarjetaShopping"] = "targeta-shopping";
  CreditCard2["UnionPay"] = "unionpay";
  CreditCard2["Visa"] = "visa";
  CreditCard2["MIR"] = "mir";
  CreditCard2["Maestro"] = "maestro";
  CreditCard2["Rupay"] = "rupay";
  return CreditCard2;
})(CreditCard || {});

// node_modules/node-appwrite/dist/enums/flag.mjs
var Flag = ((Flag2) => {
  Flag2["Afghanistan"] = "af";
  Flag2["Angola"] = "ao";
  Flag2["Albania"] = "al";
  Flag2["Andorra"] = "ad";
  Flag2["UnitedArabEmirates"] = "ae";
  Flag2["Argentina"] = "ar";
  Flag2["Armenia"] = "am";
  Flag2["AntiguaAndBarbuda"] = "ag";
  Flag2["Australia"] = "au";
  Flag2["Austria"] = "at";
  Flag2["Azerbaijan"] = "az";
  Flag2["Burundi"] = "bi";
  Flag2["Belgium"] = "be";
  Flag2["Benin"] = "bj";
  Flag2["BurkinaFaso"] = "bf";
  Flag2["Bangladesh"] = "bd";
  Flag2["Bulgaria"] = "bg";
  Flag2["Bahrain"] = "bh";
  Flag2["Bahamas"] = "bs";
  Flag2["BosniaAndHerzegovina"] = "ba";
  Flag2["Belarus"] = "by";
  Flag2["Belize"] = "bz";
  Flag2["Bolivia"] = "bo";
  Flag2["Brazil"] = "br";
  Flag2["Barbados"] = "bb";
  Flag2["BruneiDarussalam"] = "bn";
  Flag2["Bhutan"] = "bt";
  Flag2["Botswana"] = "bw";
  Flag2["CentralAfricanRepublic"] = "cf";
  Flag2["Canada"] = "ca";
  Flag2["Switzerland"] = "ch";
  Flag2["Chile"] = "cl";
  Flag2["China"] = "cn";
  Flag2["CoteDIvoire"] = "ci";
  Flag2["Cameroon"] = "cm";
  Flag2["DemocraticRepublicOfTheCongo"] = "cd";
  Flag2["RepublicOfTheCongo"] = "cg";
  Flag2["Colombia"] = "co";
  Flag2["Comoros"] = "km";
  Flag2["CapeVerde"] = "cv";
  Flag2["CostaRica"] = "cr";
  Flag2["Cuba"] = "cu";
  Flag2["Cyprus"] = "cy";
  Flag2["CzechRepublic"] = "cz";
  Flag2["Germany"] = "de";
  Flag2["Djibouti"] = "dj";
  Flag2["Dominica"] = "dm";
  Flag2["Denmark"] = "dk";
  Flag2["DominicanRepublic"] = "do";
  Flag2["Algeria"] = "dz";
  Flag2["Ecuador"] = "ec";
  Flag2["Egypt"] = "eg";
  Flag2["Eritrea"] = "er";
  Flag2["Spain"] = "es";
  Flag2["Estonia"] = "ee";
  Flag2["Ethiopia"] = "et";
  Flag2["Finland"] = "fi";
  Flag2["Fiji"] = "fj";
  Flag2["France"] = "fr";
  Flag2["MicronesiaFederatedStatesOf"] = "fm";
  Flag2["Gabon"] = "ga";
  Flag2["UnitedKingdom"] = "gb";
  Flag2["Georgia"] = "ge";
  Flag2["Ghana"] = "gh";
  Flag2["Guinea"] = "gn";
  Flag2["Gambia"] = "gm";
  Flag2["GuineaBissau"] = "gw";
  Flag2["EquatorialGuinea"] = "gq";
  Flag2["Greece"] = "gr";
  Flag2["Grenada"] = "gd";
  Flag2["Guatemala"] = "gt";
  Flag2["Guyana"] = "gy";
  Flag2["Honduras"] = "hn";
  Flag2["Croatia"] = "hr";
  Flag2["Haiti"] = "ht";
  Flag2["Hungary"] = "hu";
  Flag2["Indonesia"] = "id";
  Flag2["India"] = "in";
  Flag2["Ireland"] = "ie";
  Flag2["IranIslamicRepublicOf"] = "ir";
  Flag2["Iraq"] = "iq";
  Flag2["Iceland"] = "is";
  Flag2["Israel"] = "il";
  Flag2["Italy"] = "it";
  Flag2["Jamaica"] = "jm";
  Flag2["Jordan"] = "jo";
  Flag2["Japan"] = "jp";
  Flag2["Kazakhstan"] = "kz";
  Flag2["Kenya"] = "ke";
  Flag2["Kyrgyzstan"] = "kg";
  Flag2["Cambodia"] = "kh";
  Flag2["Kiribati"] = "ki";
  Flag2["SaintKittsAndNevis"] = "kn";
  Flag2["SouthKorea"] = "kr";
  Flag2["Kuwait"] = "kw";
  Flag2["LaoPeopleSDemocraticRepublic"] = "la";
  Flag2["Lebanon"] = "lb";
  Flag2["Liberia"] = "lr";
  Flag2["Libya"] = "ly";
  Flag2["SaintLucia"] = "lc";
  Flag2["Liechtenstein"] = "li";
  Flag2["SriLanka"] = "lk";
  Flag2["Lesotho"] = "ls";
  Flag2["Lithuania"] = "lt";
  Flag2["Luxembourg"] = "lu";
  Flag2["Latvia"] = "lv";
  Flag2["Morocco"] = "ma";
  Flag2["Monaco"] = "mc";
  Flag2["Moldova"] = "md";
  Flag2["Madagascar"] = "mg";
  Flag2["Maldives"] = "mv";
  Flag2["Mexico"] = "mx";
  Flag2["MarshallIslands"] = "mh";
  Flag2["NorthMacedonia"] = "mk";
  Flag2["Mali"] = "ml";
  Flag2["Malta"] = "mt";
  Flag2["Myanmar"] = "mm";
  Flag2["Montenegro"] = "me";
  Flag2["Mongolia"] = "mn";
  Flag2["Mozambique"] = "mz";
  Flag2["Mauritania"] = "mr";
  Flag2["Mauritius"] = "mu";
  Flag2["Malawi"] = "mw";
  Flag2["Malaysia"] = "my";
  Flag2["Namibia"] = "na";
  Flag2["Niger"] = "ne";
  Flag2["Nigeria"] = "ng";
  Flag2["Nicaragua"] = "ni";
  Flag2["Netherlands"] = "nl";
  Flag2["Norway"] = "no";
  Flag2["Nepal"] = "np";
  Flag2["Nauru"] = "nr";
  Flag2["NewZealand"] = "nz";
  Flag2["Oman"] = "om";
  Flag2["Pakistan"] = "pk";
  Flag2["Panama"] = "pa";
  Flag2["Peru"] = "pe";
  Flag2["Philippines"] = "ph";
  Flag2["Palau"] = "pw";
  Flag2["PapuaNewGuinea"] = "pg";
  Flag2["Poland"] = "pl";
  Flag2["FrenchPolynesia"] = "pf";
  Flag2["NorthKorea"] = "kp";
  Flag2["Portugal"] = "pt";
  Flag2["Paraguay"] = "py";
  Flag2["Qatar"] = "qa";
  Flag2["Romania"] = "ro";
  Flag2["Russia"] = "ru";
  Flag2["Rwanda"] = "rw";
  Flag2["SaudiArabia"] = "sa";
  Flag2["Sudan"] = "sd";
  Flag2["Senegal"] = "sn";
  Flag2["Singapore"] = "sg";
  Flag2["SolomonIslands"] = "sb";
  Flag2["SierraLeone"] = "sl";
  Flag2["ElSalvador"] = "sv";
  Flag2["SanMarino"] = "sm";
  Flag2["Somalia"] = "so";
  Flag2["Serbia"] = "rs";
  Flag2["SouthSudan"] = "ss";
  Flag2["SaoTomeAndPrincipe"] = "st";
  Flag2["Suriname"] = "sr";
  Flag2["Slovakia"] = "sk";
  Flag2["Slovenia"] = "si";
  Flag2["Sweden"] = "se";
  Flag2["Eswatini"] = "sz";
  Flag2["Seychelles"] = "sc";
  Flag2["Syria"] = "sy";
  Flag2["Chad"] = "td";
  Flag2["Togo"] = "tg";
  Flag2["Thailand"] = "th";
  Flag2["Tajikistan"] = "tj";
  Flag2["Turkmenistan"] = "tm";
  Flag2["TimorLeste"] = "tl";
  Flag2["Tonga"] = "to";
  Flag2["TrinidadAndTobago"] = "tt";
  Flag2["Tunisia"] = "tn";
  Flag2["Turkey"] = "tr";
  Flag2["Tuvalu"] = "tv";
  Flag2["Tanzania"] = "tz";
  Flag2["Uganda"] = "ug";
  Flag2["Ukraine"] = "ua";
  Flag2["Uruguay"] = "uy";
  Flag2["UnitedStates"] = "us";
  Flag2["Uzbekistan"] = "uz";
  Flag2["VaticanCity"] = "va";
  Flag2["SaintVincentAndTheGrenadines"] = "vc";
  Flag2["Venezuela"] = "ve";
  Flag2["Vietnam"] = "vn";
  Flag2["Vanuatu"] = "vu";
  Flag2["Samoa"] = "ws";
  Flag2["Yemen"] = "ye";
  Flag2["SouthAfrica"] = "za";
  Flag2["Zambia"] = "zm";
  Flag2["Zimbabwe"] = "zw";
  return Flag2;
})(Flag || {});

// node_modules/node-appwrite/dist/enums/relationship-type.mjs
var RelationshipType = ((RelationshipType2) => {
  RelationshipType2["OneToOne"] = "oneToOne";
  RelationshipType2["ManyToOne"] = "manyToOne";
  RelationshipType2["ManyToMany"] = "manyToMany";
  RelationshipType2["OneToMany"] = "oneToMany";
  return RelationshipType2;
})(RelationshipType || {});

// node_modules/node-appwrite/dist/enums/relation-mutate.mjs
var RelationMutate = ((RelationMutate2) => {
  RelationMutate2["Cascade"] = "cascade";
  RelationMutate2["Restrict"] = "restrict";
  RelationMutate2["SetNull"] = "setNull";
  return RelationMutate2;
})(RelationMutate || {});

// node_modules/node-appwrite/dist/enums/index-type.mjs
var IndexType = ((IndexType2) => {
  IndexType2["Key"] = "key";
  IndexType2["Fulltext"] = "fulltext";
  IndexType2["Unique"] = "unique";
  IndexType2["Spatial"] = "spatial";
  return IndexType2;
})(IndexType || {});

// node_modules/node-appwrite/dist/enums/runtime.mjs
var Runtime = ((Runtime2) => {
  Runtime2["Node145"] = "node-14.5";
  Runtime2["Node160"] = "node-16.0";
  Runtime2["Node180"] = "node-18.0";
  Runtime2["Node190"] = "node-19.0";
  Runtime2["Node200"] = "node-20.0";
  Runtime2["Node210"] = "node-21.0";
  Runtime2["Node22"] = "node-22";
  Runtime2["Php80"] = "php-8.0";
  Runtime2["Php81"] = "php-8.1";
  Runtime2["Php82"] = "php-8.2";
  Runtime2["Php83"] = "php-8.3";
  Runtime2["Ruby30"] = "ruby-3.0";
  Runtime2["Ruby31"] = "ruby-3.1";
  Runtime2["Ruby32"] = "ruby-3.2";
  Runtime2["Ruby33"] = "ruby-3.3";
  Runtime2["Python38"] = "python-3.8";
  Runtime2["Python39"] = "python-3.9";
  Runtime2["Python310"] = "python-3.10";
  Runtime2["Python311"] = "python-3.11";
  Runtime2["Python312"] = "python-3.12";
  Runtime2["Pythonml311"] = "python-ml-3.11";
  Runtime2["Pythonml312"] = "python-ml-3.12";
  Runtime2["Deno121"] = "deno-1.21";
  Runtime2["Deno124"] = "deno-1.24";
  Runtime2["Deno135"] = "deno-1.35";
  Runtime2["Deno140"] = "deno-1.40";
  Runtime2["Deno146"] = "deno-1.46";
  Runtime2["Deno20"] = "deno-2.0";
  Runtime2["Dart215"] = "dart-2.15";
  Runtime2["Dart216"] = "dart-2.16";
  Runtime2["Dart217"] = "dart-2.17";
  Runtime2["Dart218"] = "dart-2.18";
  Runtime2["Dart219"] = "dart-2.19";
  Runtime2["Dart30"] = "dart-3.0";
  Runtime2["Dart31"] = "dart-3.1";
  Runtime2["Dart33"] = "dart-3.3";
  Runtime2["Dart35"] = "dart-3.5";
  Runtime2["Dart38"] = "dart-3.8";
  Runtime2["Dotnet60"] = "dotnet-6.0";
  Runtime2["Dotnet70"] = "dotnet-7.0";
  Runtime2["Dotnet80"] = "dotnet-8.0";
  Runtime2["Java80"] = "java-8.0";
  Runtime2["Java110"] = "java-11.0";
  Runtime2["Java170"] = "java-17.0";
  Runtime2["Java180"] = "java-18.0";
  Runtime2["Java210"] = "java-21.0";
  Runtime2["Java22"] = "java-22";
  Runtime2["Swift55"] = "swift-5.5";
  Runtime2["Swift58"] = "swift-5.8";
  Runtime2["Swift59"] = "swift-5.9";
  Runtime2["Swift510"] = "swift-5.10";
  Runtime2["Kotlin16"] = "kotlin-1.6";
  Runtime2["Kotlin18"] = "kotlin-1.8";
  Runtime2["Kotlin19"] = "kotlin-1.9";
  Runtime2["Kotlin20"] = "kotlin-2.0";
  Runtime2["Cpp17"] = "cpp-17";
  Runtime2["Cpp20"] = "cpp-20";
  Runtime2["Bun10"] = "bun-1.0";
  Runtime2["Bun11"] = "bun-1.1";
  Runtime2["Go123"] = "go-1.23";
  Runtime2["Static1"] = "static-1";
  Runtime2["Flutter324"] = "flutter-3.24";
  Runtime2["Flutter327"] = "flutter-3.27";
  Runtime2["Flutter329"] = "flutter-3.29";
  Runtime2["Flutter332"] = "flutter-3.32";
  return Runtime2;
})(Runtime || {});

// node_modules/node-appwrite/dist/enums/vcs-deployment-type.mjs
var VCSDeploymentType = ((VCSDeploymentType2) => {
  VCSDeploymentType2["Branch"] = "branch";
  VCSDeploymentType2["Commit"] = "commit";
  VCSDeploymentType2["Tag"] = "tag";
  return VCSDeploymentType2;
})(VCSDeploymentType || {});

// node_modules/node-appwrite/dist/enums/deployment-download-type.mjs
var DeploymentDownloadType = ((DeploymentDownloadType2) => {
  DeploymentDownloadType2["Source"] = "source";
  DeploymentDownloadType2["Output"] = "output";
  return DeploymentDownloadType2;
})(DeploymentDownloadType || {});

// node_modules/node-appwrite/dist/enums/execution-method.mjs
var ExecutionMethod = ((ExecutionMethod2) => {
  ExecutionMethod2["GET"] = "GET";
  ExecutionMethod2["POST"] = "POST";
  ExecutionMethod2["PUT"] = "PUT";
  ExecutionMethod2["PATCH"] = "PATCH";
  ExecutionMethod2["DELETE"] = "DELETE";
  ExecutionMethod2["OPTIONS"] = "OPTIONS";
  ExecutionMethod2["HEAD"] = "HEAD";
  return ExecutionMethod2;
})(ExecutionMethod || {});

// node_modules/node-appwrite/dist/enums/name.mjs
var Name = ((Name2) => {
  Name2["V1database"] = "v1-database";
  Name2["V1deletes"] = "v1-deletes";
  Name2["V1audits"] = "v1-audits";
  Name2["V1mails"] = "v1-mails";
  Name2["V1functions"] = "v1-functions";
  Name2["V1statsresources"] = "v1-stats-resources";
  Name2["V1statsusage"] = "v1-stats-usage";
  Name2["V1webhooks"] = "v1-webhooks";
  Name2["V1certificates"] = "v1-certificates";
  Name2["V1builds"] = "v1-builds";
  Name2["V1messaging"] = "v1-messaging";
  Name2["V1migrations"] = "v1-migrations";
  return Name2;
})(Name || {});

// node_modules/node-appwrite/dist/enums/message-priority.mjs
var MessagePriority = ((MessagePriority2) => {
  MessagePriority2["Normal"] = "normal";
  MessagePriority2["High"] = "high";
  return MessagePriority2;
})(MessagePriority || {});

// node_modules/node-appwrite/dist/enums/smtp-encryption.mjs
var SmtpEncryption = ((SmtpEncryption2) => {
  SmtpEncryption2["None"] = "none";
  SmtpEncryption2["Ssl"] = "ssl";
  SmtpEncryption2["Tls"] = "tls";
  return SmtpEncryption2;
})(SmtpEncryption || {});

// node_modules/node-appwrite/dist/enums/framework.mjs
var Framework = ((Framework2) => {
  Framework2["Analog"] = "analog";
  Framework2["Angular"] = "angular";
  Framework2["Nextjs"] = "nextjs";
  Framework2["React"] = "react";
  Framework2["Nuxt"] = "nuxt";
  Framework2["Vue"] = "vue";
  Framework2["Sveltekit"] = "sveltekit";
  Framework2["Astro"] = "astro";
  Framework2["Remix"] = "remix";
  Framework2["Lynx"] = "lynx";
  Framework2["Flutter"] = "flutter";
  Framework2["Reactnative"] = "react-native";
  Framework2["Vite"] = "vite";
  Framework2["Other"] = "other";
  return Framework2;
})(Framework || {});

// node_modules/node-appwrite/dist/enums/build-runtime.mjs
var BuildRuntime = ((BuildRuntime2) => {
  BuildRuntime2["Node145"] = "node-14.5";
  BuildRuntime2["Node160"] = "node-16.0";
  BuildRuntime2["Node180"] = "node-18.0";
  BuildRuntime2["Node190"] = "node-19.0";
  BuildRuntime2["Node200"] = "node-20.0";
  BuildRuntime2["Node210"] = "node-21.0";
  BuildRuntime2["Node22"] = "node-22";
  BuildRuntime2["Php80"] = "php-8.0";
  BuildRuntime2["Php81"] = "php-8.1";
  BuildRuntime2["Php82"] = "php-8.2";
  BuildRuntime2["Php83"] = "php-8.3";
  BuildRuntime2["Ruby30"] = "ruby-3.0";
  BuildRuntime2["Ruby31"] = "ruby-3.1";
  BuildRuntime2["Ruby32"] = "ruby-3.2";
  BuildRuntime2["Ruby33"] = "ruby-3.3";
  BuildRuntime2["Python38"] = "python-3.8";
  BuildRuntime2["Python39"] = "python-3.9";
  BuildRuntime2["Python310"] = "python-3.10";
  BuildRuntime2["Python311"] = "python-3.11";
  BuildRuntime2["Python312"] = "python-3.12";
  BuildRuntime2["Pythonml311"] = "python-ml-3.11";
  BuildRuntime2["Pythonml312"] = "python-ml-3.12";
  BuildRuntime2["Deno121"] = "deno-1.21";
  BuildRuntime2["Deno124"] = "deno-1.24";
  BuildRuntime2["Deno135"] = "deno-1.35";
  BuildRuntime2["Deno140"] = "deno-1.40";
  BuildRuntime2["Deno146"] = "deno-1.46";
  BuildRuntime2["Deno20"] = "deno-2.0";
  BuildRuntime2["Dart215"] = "dart-2.15";
  BuildRuntime2["Dart216"] = "dart-2.16";
  BuildRuntime2["Dart217"] = "dart-2.17";
  BuildRuntime2["Dart218"] = "dart-2.18";
  BuildRuntime2["Dart219"] = "dart-2.19";
  BuildRuntime2["Dart30"] = "dart-3.0";
  BuildRuntime2["Dart31"] = "dart-3.1";
  BuildRuntime2["Dart33"] = "dart-3.3";
  BuildRuntime2["Dart35"] = "dart-3.5";
  BuildRuntime2["Dart38"] = "dart-3.8";
  BuildRuntime2["Dotnet60"] = "dotnet-6.0";
  BuildRuntime2["Dotnet70"] = "dotnet-7.0";
  BuildRuntime2["Dotnet80"] = "dotnet-8.0";
  BuildRuntime2["Java80"] = "java-8.0";
  BuildRuntime2["Java110"] = "java-11.0";
  BuildRuntime2["Java170"] = "java-17.0";
  BuildRuntime2["Java180"] = "java-18.0";
  BuildRuntime2["Java210"] = "java-21.0";
  BuildRuntime2["Java22"] = "java-22";
  BuildRuntime2["Swift55"] = "swift-5.5";
  BuildRuntime2["Swift58"] = "swift-5.8";
  BuildRuntime2["Swift59"] = "swift-5.9";
  BuildRuntime2["Swift510"] = "swift-5.10";
  BuildRuntime2["Kotlin16"] = "kotlin-1.6";
  BuildRuntime2["Kotlin18"] = "kotlin-1.8";
  BuildRuntime2["Kotlin19"] = "kotlin-1.9";
  BuildRuntime2["Kotlin20"] = "kotlin-2.0";
  BuildRuntime2["Cpp17"] = "cpp-17";
  BuildRuntime2["Cpp20"] = "cpp-20";
  BuildRuntime2["Bun10"] = "bun-1.0";
  BuildRuntime2["Bun11"] = "bun-1.1";
  BuildRuntime2["Go123"] = "go-1.23";
  BuildRuntime2["Static1"] = "static-1";
  BuildRuntime2["Flutter324"] = "flutter-3.24";
  BuildRuntime2["Flutter327"] = "flutter-3.27";
  BuildRuntime2["Flutter329"] = "flutter-3.29";
  BuildRuntime2["Flutter332"] = "flutter-3.32";
  return BuildRuntime2;
})(BuildRuntime || {});

// node_modules/node-appwrite/dist/enums/adapter.mjs
var Adapter = ((Adapter2) => {
  Adapter2["Static"] = "static";
  Adapter2["Ssr"] = "ssr";
  return Adapter2;
})(Adapter || {});

// node_modules/node-appwrite/dist/enums/compression.mjs
var Compression = ((Compression2) => {
  Compression2["None"] = "none";
  Compression2["Gzip"] = "gzip";
  Compression2["Zstd"] = "zstd";
  return Compression2;
})(Compression || {});

// node_modules/node-appwrite/dist/enums/image-gravity.mjs
var ImageGravity = ((ImageGravity2) => {
  ImageGravity2["Center"] = "center";
  ImageGravity2["Topleft"] = "top-left";
  ImageGravity2["Top"] = "top";
  ImageGravity2["Topright"] = "top-right";
  ImageGravity2["Left"] = "left";
  ImageGravity2["Right"] = "right";
  ImageGravity2["Bottomleft"] = "bottom-left";
  ImageGravity2["Bottom"] = "bottom";
  ImageGravity2["Bottomright"] = "bottom-right";
  return ImageGravity2;
})(ImageGravity || {});

// node_modules/node-appwrite/dist/enums/image-format.mjs
var ImageFormat = ((ImageFormat2) => {
  ImageFormat2["Jpg"] = "jpg";
  ImageFormat2["Jpeg"] = "jpeg";
  ImageFormat2["Png"] = "png";
  ImageFormat2["Webp"] = "webp";
  ImageFormat2["Heic"] = "heic";
  ImageFormat2["Avif"] = "avif";
  ImageFormat2["Gif"] = "gif";
  return ImageFormat2;
})(ImageFormat || {});

// node_modules/node-appwrite/dist/enums/password-hash.mjs
var PasswordHash = ((PasswordHash2) => {
  PasswordHash2["Sha1"] = "sha1";
  PasswordHash2["Sha224"] = "sha224";
  PasswordHash2["Sha256"] = "sha256";
  PasswordHash2["Sha384"] = "sha384";
  PasswordHash2["Sha512224"] = "sha512/224";
  PasswordHash2["Sha512256"] = "sha512/256";
  PasswordHash2["Sha512"] = "sha512";
  PasswordHash2["Sha3224"] = "sha3-224";
  PasswordHash2["Sha3256"] = "sha3-256";
  PasswordHash2["Sha3384"] = "sha3-384";
  PasswordHash2["Sha3512"] = "sha3-512";
  return PasswordHash2;
})(PasswordHash || {});

// node_modules/node-appwrite/dist/enums/messaging-provider-type.mjs
var MessagingProviderType = ((MessagingProviderType2) => {
  MessagingProviderType2["Email"] = "email";
  MessagingProviderType2["Sms"] = "sms";
  MessagingProviderType2["Push"] = "push";
  return MessagingProviderType2;
})(MessagingProviderType || {});
export {
  Account,
  Adapter,
  AppwriteException,
  AuthenticationFactor,
  AuthenticatorType,
  Avatars,
  Browser,
  BuildRuntime,
  Client,
  Compression,
  CreditCard,
  Databases,
  DeploymentDownloadType,
  ExecutionMethod,
  Flag,
  Framework,
  Functions,
  Graphql,
  Health,
  ID,
  ImageFormat,
  ImageGravity,
  IndexType,
  Locale,
  MessagePriority,
  Messaging,
  MessagingProviderType,
  Name,
  OAuthProvider,
  PasswordHash,
  Permission,
  Query,
  RelationMutate,
  RelationshipType,
  Role,
  Runtime,
  Sites,
  SmtpEncryption,
  Storage,
  TablesDB,
  Teams,
  Tokens,
  Users,
  VCSDeploymentType
};
//# sourceMappingURL=node-appwrite.js.map
